#!/usr/bin/env python3
"""
Push-to-Talk Speech-to-Text Dictation Tool - Enhanced Edition

A feature-rich dictation tool with configurable hotkeys, audio feedback,
punctuation commands, continuous mode, and system tray integration.

Architecture:
- Module 1: Configuration Manager
- Module 2: Global Hotkey Listener (pynput)
- Module 3: Audio Capture with Feedback (PyAudio)
- Module 4: STT Engine (faster-whisper)
- Module 5: Text Processing (punctuation, vocabulary)
- Module 6: Text Injection (pynput)
- Module 7: System Tray Icon (pystray)
- Module 8: Wake Word Detection (optional)
"""

import io
import logging
import os
import platform
import queue
import re
import sys
import threading
import time
import tkinter as tk
import wave
from typing import Callable, Dict, List, Optional, Set

import numpy as np
import pyaudio
import yaml
from faster_whisper import WhisperModel
from PIL import Image, ImageDraw
from pynput import keyboard, mouse
from pystray import Icon, Menu, MenuItem

try:
    import pyautogui

    PYAUTOGUI_AVAILABLE = True
except ImportError:
    PYAUTOGUI_AVAILABLE = False
    logging.warning("pyautogui not available. Screen segmentation features disabled.")

# File watching for auto-reload
try:
    from watchdog.observers import Observer
    from watchdog.events import FileSystemEventHandler
    WATCHDOG_AVAILABLE = True
except ImportError:
    WATCHDOG_AVAILABLE = False
    print("âš ï¸  watchdog not installed - auto-reload disabled. Install with: pip install watchdog")

# Platform-specific UI automation imports
PYWINAUTO_AVAILABLE = False
if platform.system() == "Windows":
    try:
        import pywinauto  # noqa: F401

        PYWINAUTO_AVAILABLE = True
    except ImportError:
        logging.warning("pywinauto not available. Advanced element detection disabled on Windows.")

# --- Key Mapping for Left/Right Variants ---
# Map physical keys to canonical keys (handles left/right variants)
KEY_MAPPING = {
    keyboard.Key.ctrl_l: keyboard.Key.ctrl,
    keyboard.Key.ctrl_r: keyboard.Key.ctrl,
    keyboard.Key.cmd_l: keyboard.Key.cmd,
    keyboard.Key.cmd_r: keyboard.Key.cmd,
    keyboard.Key.shift_l: keyboard.Key.shift,
    keyboard.Key.shift_r: keyboard.Key.shift,
    keyboard.Key.alt_l: keyboard.Key.alt,
    keyboard.Key.alt_r: keyboard.Key.alt,
}

# --- Module 1: Configuration Manager ---


class Config:
    """Configuration manager for the dictation tool."""

    def __init__(self, config_path: str = "config.yaml"):
        self.config_path = config_path
        self.config = self._load_config()
        self._setup_logging()

    def _load_config(self) -> Dict:
        """Load configuration from YAML file."""
        if not os.path.exists(self.config_path):
            print(f"âš  Config file not found at {self.config_path}")
            print("Creating default configuration...")
            return self._get_default_config()

        try:
            with open(self.config_path, "r") as f:
                config = yaml.safe_load(f)
            print(f"âœ“ Configuration loaded from {self.config_path}")
            return config
        except Exception as e:
            print(f"âœ— Error loading config: {e}")
            print("Using default configuration...")
            return self._get_default_config()

    def _get_default_config(self) -> Dict:
        """Return default configuration."""
        return {
            "hotkeys": {
                "push_to_talk": ["ctrl", "cmd"],
                "toggle_continuous": ["ctrl", "shift", "d"],
            },
            "audio": {
                "sample_rate": 16000,
                "channels": 1,
                "chunk_size": 1024,
                "beep_on_start": True,
                "beep_on_stop": True,
                "start_beep_frequency": 800,
                "start_beep_duration": 100,
                "stop_beep_frequency": 600,
                "stop_beep_duration": 100,
            },
            "model": {
                "name": "small.en",
                "device": "auto",
                "compute_type": "int8",
                "beam_size": 5,
                "language": "en",
            },
            "text_processing": {
                "punctuation_commands": True,
                "punctuation_map": {
                    "period": ".",
                    "comma": ",",
                    "question mark": "?",
                    "exclamation point": "!",
                    "new line": "\n",
                    "new paragraph": "\n\n",
                },
                "custom_vocabulary": {},
                "command_words": {
                    "delete that": "undo_last",
                    "scratch that": "undo_last",
                },
            },
            "continuous_mode": {
                "enabled": False,
                "silence_threshold": 2.0,
                "minimum_audio_length": 0.5,
            },
            "system_tray": {
                "enabled": True,
                "show_notifications": True,
                "notification_duration": 2,
            },
            "wake_word": {"enabled": False, "word": "hey computer", "sensitivity": 0.5},
            "advanced": {
                "log_level": "INFO",
                "verbose": False,
                "max_recording_duration": 60,
                "transcription_threads": 1,
            },
        }

    def _setup_logging(self) -> None:
        """Setup logging based on configuration."""
        log_level = getattr(logging, self.config["advanced"].get("log_level", "INFO"), logging.INFO)
        logging.basicConfig(
            level=log_level,
            format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        )

    def get(self, *keys, default=None):
        """Get a nested configuration value."""
        value = self.config
        for key in keys:
            if isinstance(value, dict):
                value = value.get(key)
                if value is None:
                    return default
            else:
                return default
        return value


# --- Module 2: Audio Feedback Generator ---


class AudioFeedback:
    """Generate audio feedback beeps."""

    @staticmethod
    def generate_beep(frequency: int, duration: int, sample_rate: int = 44100) -> bytes:
        """Generate a beep sound."""
        samples = int(sample_rate * duration / 1000)
        t = np.linspace(0, duration / 1000, samples, False)
        wave_data = np.sin(frequency * t * 2 * np.pi)

        # Apply fade in/out to avoid clicks
        fade_samples = int(samples * 0.1)
        fade_in = np.linspace(0, 1, fade_samples)
        fade_out = np.linspace(1, 0, fade_samples)
        wave_data[:fade_samples] *= fade_in
        wave_data[-fade_samples:] *= fade_out

        # Convert to 16-bit PCM
        audio = (wave_data * 32767).astype(np.int16)
        return audio.tobytes()

    @staticmethod
    def play_beep(frequency: int, duration: int, pyaudio_instance):
        """Play a beep sound."""
        stream = None
        try:
            beep_data = AudioFeedback.generate_beep(frequency, duration)
            stream = pyaudio_instance.open(
                format=pyaudio.paInt16, channels=1, rate=44100, output=True
            )
            stream.write(beep_data)
        except Exception as e:
            logging.warning(f"Failed to play beep: {e}")
        finally:
            if stream:
                stream.stop_stream()
                stream.close()


# --- Module 3: Numbered Overlay for Screen Element Segmentation ---


class NumberedOverlay:
    """
    Numbered overlay for screen element segmentation.
    Displays clickable numbered labels on screen for voice control.
    """

    def __init__(self):
        self.logger = logging.getLogger("NumberedOverlay")
        self.root = None
        self.canvas = None
        self.elements = {}  # Maps number -> (x, y, width, height)
        self.labels = []  # List of label widgets
        self.is_visible = False
        self.mode = None  # 'grid' or 'elements'
        self.grid_level = 0  # For hierarchical grid zooming
        self.grid_offset = (0, 0)  # Current grid offset for zooming

        # Thread-safe command queue for GUI operations
        self.command_queue = queue.Queue()

        # Start GUI thread
        self.gui_thread = threading.Thread(target=self._run_gui_thread, daemon=True)
        self.gui_thread.start()

    def _run_gui_thread(self):
        """Run the tkinter GUI in a dedicated thread."""
        # Create hidden root window
        self.root = tk.Tk()
        self.root.withdraw()  # Hide initially

        # Process queue periodically
        def process_queue():
            try:
                while True:
                    cmd, args, kwargs = self.command_queue.get_nowait()
                    cmd(*args, **kwargs)
            except queue.Empty:
                pass
            finally:
                # Check queue again after 100ms
                self.root.after(100, process_queue)

        process_queue()
        self.root.mainloop()

    def _queue_command(self, cmd: Callable, *args, **kwargs):
        """Queue a command to be executed on the GUI thread."""
        self.command_queue.put((cmd, args, kwargs))

    def show_grid(self, subdivisions: int = 9):
        """Show a numbered grid overlay for precision clicking."""
        if not PYAUTOGUI_AVAILABLE:
            print("âš  PyAutoGUI not available. Install with: pip install pyautogui")
            return

        # Queue the GUI operations
        self._queue_command(self._show_grid_impl, subdivisions)

    def refine_grid_cell(self, cell_number: int):
        """Zoom into a specific cell with a 3x3 subdivision."""
        if not PYAUTOGUI_AVAILABLE:
            print("âš  PyAutoGUI not available. Install with: pip install pyautogui")
            return

        # Queue the GUI operations
        self._queue_command(self._refine_grid_cell_impl, cell_number)

    def _show_grid_impl(self, subdivisions: int):
        """Implementation of show_grid - runs on GUI thread."""
        self._cleanup_impl()

        # Get screen size
        screen_width, screen_height = pyautogui.size()

        # Calculate grid cell size
        cell_width = screen_width // subdivisions
        cell_height = screen_height // subdivisions

        # Setup overlay window
        self.root.deiconify()  # Show window
        self.root.attributes("-fullscreen", True)
        self.root.attributes("-topmost", True)
        self.root.attributes("-alpha", 0.7)
        self.root.config(bg="black")
        self.root.title("Voice Control Grid")

        # Make window click-through
        self.root.attributes("-transparentcolor", "black")

        # Create or clear canvas
        if self.canvas:
            self.canvas.delete("all")
        else:
            self.canvas = tk.Canvas(
                self.root,
                bg="black",
                highlightthickness=0,
                width=screen_width,
                height=screen_height,
            )
            self.canvas.pack()

        # Draw grid and create numbered elements
        self.elements.clear()
        number = 1
        for row in range(subdivisions):
            for col in range(subdivisions):
                x1 = col * cell_width
                y1 = row * cell_height
                x2 = x1 + cell_width
                y2 = y1 + cell_height

                # Draw grid cell border
                self.canvas.create_rectangle(
                    x1, y1, x2, y2, outline="cyan", width=2, fill="", stipple="gray12"
                )

                # Calculate center position for label
                center_x = x1 + cell_width // 2
                center_y = y1 + cell_height // 2

                # Store element position (center of grid cell)
                self.elements[number] = (center_x, center_y, cell_width, cell_height)

                # Create label with background
                self.canvas.create_oval(
                    center_x - 25,
                    center_y - 25,
                    center_x + 25,
                    center_y + 25,
                    fill="cyan",
                    outline="blue",
                    width=3,
                )
                self.canvas.create_text(
                    center_x,
                    center_y,
                    text=str(number),
                    font=("Arial", 24, "bold"),
                    fill="black",
                )

                number += 1

        self.mode = "grid"
        self.is_visible = True
        print(f"âœ“ Grid overlay shown with {len(self.elements)} cells")
        print("  Say '[number]' to move mouse to cell")
        print("  Say 'CLICK' to click")
        print("  Say 'REFINE [number]' to zoom into a cell")
        print("  Say 'HIDE NUMBERS' to close")

    def _refine_grid_cell_impl(self, cell_number: int):
        """Implementation of refine_grid_cell - runs on GUI thread."""
        # Check if cell exists
        if cell_number not in self.elements:
            print(f"âš  Cell {cell_number} not found in current grid")
            return

        # Get the bounds of the cell to zoom into
        center_x, center_y, cell_width, cell_height = self.elements[cell_number]

        # Calculate the bounds of the cell
        x_start = center_x - cell_width // 2
        y_start = center_y - cell_height // 2

        print(f"ðŸ” Zooming into cell {cell_number}...")

        # Get screen size for overlay
        screen_width, screen_height = pyautogui.size()

        # Clear current canvas
        if self.canvas:
            self.canvas.delete("all")
        else:
            self.canvas = tk.Canvas(
                self.root,
                bg="black",
                highlightthickness=0,
                width=screen_width,
                height=screen_height,
            )
            self.canvas.pack()

        # Create 3x3 grid within the cell bounds
        subdivisions = 3
        sub_cell_width = cell_width // subdivisions
        sub_cell_height = cell_height // subdivisions

        # Draw the zoomed 3x3 grid
        self.elements.clear()
        number = 1
        for row in range(subdivisions):
            for col in range(subdivisions):
                x1 = x_start + col * sub_cell_width
                y1 = y_start + row * sub_cell_height
                x2 = x1 + sub_cell_width
                y2 = y1 + sub_cell_height

                # Draw grid cell border (use different color to show it's zoomed)
                self.canvas.create_rectangle(
                    x1, y1, x2, y2, outline="lime", width=3, fill="", stipple="gray12"
                )

                # Calculate center position for label
                sub_center_x = x1 + sub_cell_width // 2
                sub_center_y = y1 + sub_cell_height // 2

                # Store element position
                self.elements[number] = (
                    sub_center_x,
                    sub_center_y,
                    sub_cell_width,
                    sub_cell_height,
                )

                # Create label with background (use lime to indicate zoomed mode)
                self.canvas.create_oval(
                    sub_center_x - 25,
                    sub_center_y - 25,
                    sub_center_x + 25,
                    sub_center_y + 25,
                    fill="lime",
                    outline="green",
                    width=3,
                )
                self.canvas.create_text(
                    sub_center_x,
                    sub_center_y,
                    text=str(number),
                    font=("Arial", 24, "bold"),
                    fill="black",
                )

                number += 1

        self.mode = "grid_zoomed"
        print(f"âœ“ Zoomed into cell {cell_number} with 3Ã—3 grid (9 cells)")
        print("  Say '[number]' to move mouse to cell")
        print("  Say 'CLICK' to click")
        print("  Say 'GRID' to reset to full grid")

    def show_numbers(self, max_elements: int = 25):
        """
        Show numbered overlays on clickable screen elements.
        Uses advanced UI detection on Windows, falls back to grid on other platforms.
        """
        if not PYAUTOGUI_AVAILABLE:
            print("âš  PyAutoGUI not available. Install with: pip install pyautogui")
            return

        # Queue the command
        self._queue_command(self._show_numbers_impl, max_elements)

    def _show_numbers_impl(self, max_elements: int):
        """Implementation of show_numbers - runs on GUI thread."""
        # Try advanced element detection
        if PYWINAUTO_AVAILABLE:
            try:
                self._show_detected_elements_impl(max_elements)
                return
            except Exception as e:
                self.logger.warning(f"Element detection failed: {e}, falling back to grid")
                print("âš  Advanced detection failed, using grid mode")

        # Fallback to grid mode
        self._show_grid_impl(subdivisions=5)  # 5x5 grid = 25 elements

    def _show_detected_elements_impl(self, max_elements: int):
        """Detect and show actual UI elements using Windows UI Automation."""
        if not PYWINAUTO_AVAILABLE:
            raise ImportError("pywinauto not available")

        print("ðŸ” Detecting UI elements...")
        self._cleanup_impl()

        # Get foreground window using Windows API
        try:
            import ctypes

            # Get foreground window handle
            hwnd = ctypes.windll.user32.GetForegroundWindow()
            if not hwnd:
                raise Exception("Could not get foreground window handle")

            print(f"ðŸªŸ Foreground window handle: {hwnd}")

            # Connect to window using handle
            from pywinauto import Application

            app = Application(backend="uia").connect(handle=hwnd)
            active_window = app.window(handle=hwnd)

            print(f"âœ“ Connected to window: {active_window.window_text()}")

        except Exception as e:
            print(f"âš  Failed to get foreground window: {e}")
            raise Exception(f"Could not find active window: {e}")

        # Find all clickable elements
        detected_elements = []
        try:
            # Get all descendants that are clickable
            print("ðŸ”Ž Scanning for UI elements...")
            elements = active_window.descendants()
            print(f"ðŸ“Š Total descendants found: {len(elements)}")

            for elem in elements:
                try:
                    # Check if element is visible and clickable
                    if not elem.is_visible():
                        continue

                    # Get element type - we want buttons, links, etc.
                    control_type = getattr(elem.element_info, "control_type", "")

                    # Filter for interactive elements
                    if control_type in [
                        "Button",
                        "Hyperlink",
                        "MenuItem",
                        "CheckBox",
                        "RadioButton",
                        "ComboBox",
                        "Edit",
                        "ListItem",
                        "TabItem",
                    ]:
                        # Get bounding rectangle
                        rect = elem.rectangle()
                        if rect.width() > 10 and rect.height() > 10:  # Filter tiny elements
                            center_x = rect.left + rect.width() // 2
                            center_y = rect.top + rect.height() // 2

                            detected_elements.append(
                                {
                                    "x": center_x,
                                    "y": center_y,
                                    "width": rect.width(),
                                    "height": rect.height(),
                                    "name": elem.window_text(),
                                    "type": control_type,
                                }
                            )

                            if len(detected_elements) >= max_elements:
                                break
                except Exception:
                    continue

        except Exception as e:
            self.logger.warning(f"Error detecting elements: {e}")
            print(f"âš  Error scanning elements: {e}")

        if not detected_elements:
            print("âš  No clickable elements found in current window")
            raise Exception("No clickable elements found")

        print(f"âœ“ Found {len(detected_elements)} clickable elements")

        # Setup overlay window
        screen_width, screen_height = pyautogui.size()
        self.root.deiconify()  # Show window
        self.root.attributes("-fullscreen", True)
        self.root.attributes("-topmost", True)
        self.root.attributes("-alpha", 0.8)
        self.root.config(bg="black")

        # Make window click-through
        self.root.attributes("-transparentcolor", "black")

        # Create or clear canvas
        if self.canvas:
            self.canvas.delete("all")
        else:
            self.canvas = tk.Canvas(
                self.root,
                bg="black",
                highlightthickness=0,
                width=screen_width,
                height=screen_height,
            )
            self.canvas.pack()

        # Draw numbered labels over detected elements
        self.elements.clear()
        for idx, elem in enumerate(detected_elements, start=1):
            x, y = elem["x"], elem["y"]
            width, height = elem["width"], elem["height"]

            # Store element position
            self.elements[idx] = (x, y, width, height)

            # Draw bounding box
            self.canvas.create_rectangle(
                x - width // 2,
                y - height // 2,
                x + width // 2,
                y + height // 2,
                outline="lime",
                width=2,
            )

            # Create label with background
            self.canvas.create_oval(
                x - 20, y - 20, x + 20, y + 20, fill="lime", outline="green", width=3
            )
            self.canvas.create_text(x, y, text=str(idx), font=("Arial", 18, "bold"), fill="black")

        self.mode = "elements"
        self.is_visible = True
        print(f"âœ“ Element overlay shown with {len(self.elements)} elements")
        print("  Say 'CLICK [number]' to click an element")
        print("  Say 'HIDE NUMBERS' to close")

    def show_windows(self, windows_dict: Dict[int, tuple]):
        """Show numbered window list in overlay."""
        if not windows_dict:
            print("âš  No windows to display")
            return

        # Queue the GUI operations
        self._queue_command(self._show_windows_impl, windows_dict)

    def _show_windows_impl(self, windows_dict: Dict[int, tuple]):
        """Implementation of show_windows - runs on GUI thread."""
        self._cleanup_impl()

        # Get screen size
        if PYAUTOGUI_AVAILABLE:
            screen_width, screen_height = pyautogui.size()
        else:
            screen_width, screen_height = 1920, 1080

        # Setup overlay window
        self.root.deiconify()  # Show window
        self.root.attributes("-fullscreen", True)
        self.root.attributes("-topmost", True)
        self.root.attributes("-alpha", 0.8)
        self.root.config(bg="black")
        self.root.title("Window List")

        # Make window click-through (transparent black background)
        self.root.attributes("-transparentcolor", "black")

        # Create or clear canvas
        if self.canvas:
            self.canvas.delete("all")
        else:
            self.canvas = tk.Canvas(
                self.root,
                bg="black",
                highlightthickness=0,
                width=screen_width,
                height=screen_height,
            )
            self.canvas.pack()

        # Display window list
        # Create a box in the center with the list
        box_width = 800
        box_height = min(600, 50 + len(windows_dict) * 40)
        box_x = (screen_width - box_width) // 2
        box_y = (screen_height - box_height) // 2

        # Draw background box
        self.canvas.create_rectangle(
            box_x,
            box_y,
            box_x + box_width,
            box_y + box_height,
            fill="#1a1a1a",
            outline="#00ff00",
            width=3,
        )

        # Draw title
        self.canvas.create_text(
            box_x + box_width // 2,
            box_y + 25,
            text="OPEN WINDOWS - Say '[number]' to maximize | '[X] LEFT [Y] RIGHT' to split",
            font=("Arial", 12, "bold"),
            fill="#00ff00",
        )

        # Draw window list
        y_offset = box_y + 60
        for idx, (window, title) in windows_dict.items():
            # Truncate long titles
            display_title = title[:65] + "..." if len(title) > 65 else title

            # Draw number box
            num_x = box_x + 20
            self.canvas.create_rectangle(
                num_x, y_offset - 12, num_x + 40, y_offset + 12, fill="#00ff00", outline="#00ff00"
            )
            self.canvas.create_text(
                num_x + 20, y_offset, text=str(idx), font=("Arial", 14, "bold"), fill="black"
            )

            # Draw window title
            self.canvas.create_text(
                num_x + 60,
                y_offset,
                text=display_title,
                font=("Arial", 12),
                fill="white",
                anchor="w",
            )

            y_offset += 40

        # Draw close instruction
        self.canvas.create_text(
            box_x + box_width // 2,
            box_y + box_height - 20,
            text="Say 'HIDE WINDOWS' to close",
            font=("Arial", 10),
            fill="#888888",
        )

        self.mode = "windows"
        self.is_visible = True

    def hide(self):
        """Hide the numbered overlay."""
        self._queue_command(self._hide_impl)

    def _hide_impl(self):
        """Implementation of hide - runs on GUI thread."""
        self._cleanup_impl()
        print("âœ“ Overlay hidden")

    def click_element(self, number: int, button: str = "left"):
        """Click on a numbered element."""
        if number not in self.elements:
            print(f"âš  Element {number} not found")
            return

        x, y, _, _ = self.elements[number]

        # Move mouse and click
        pyautogui.moveTo(x, y, duration=0.2)
        time.sleep(0.1)

        if button == "left":
            pyautogui.click(x, y)
            print(f"âœ“ Clicked element {number} at ({x}, {y})")
        elif button == "right":
            pyautogui.rightClick(x, y)
            print(f"âœ“ Right-clicked element {number} at ({x}, {y})")
        elif button == "middle":
            pyautogui.middleClick(x, y)
            print(f"âœ“ Middle-clicked element {number} at ({x}, {y})")
        elif button == "double":
            pyautogui.doubleClick(x, y)
            print(f"âœ“ Double-clicked element {number} at ({x}, {y})")

    def show_rows(self, max_rows: int = 50):
        """Show numbered rows overlay for row selection."""
        if not PYAUTOGUI_AVAILABLE:
            print("âš  PyAutoGUI not available. Install with: pip install pyautogui")
            return

        # Queue the GUI operations
        self._queue_command(self._show_rows_impl, max_rows)

    def _show_rows_impl(self, max_rows: int):
        """Implementation of show_rows - runs on GUI thread."""
        self._cleanup_impl()

        # Get screen size
        screen_width, screen_height = pyautogui.size()

        # Calculate row height
        row_height = screen_height // max_rows

        # Setup overlay window
        self.root.deiconify()  # Show window
        self.root.attributes("-fullscreen", True)
        self.root.attributes("-topmost", True)
        self.root.attributes("-alpha", 0.7)
        self.root.config(bg="black")
        self.root.title("Voice Control Rows")

        # Make window click-through
        self.root.attributes("-transparentcolor", "black")

        # Create or clear canvas
        if self.canvas:
            self.canvas.delete("all")
        else:
            self.canvas = tk.Canvas(
                self.root,
                bg="black",
                highlightthickness=0,
                width=screen_width,
                height=screen_height,
            )
            self.canvas.pack()

        # Calculate dynamic sizing based on row height
        # Font size should be smaller to fit in row
        font_size = max(8, min(12, int(row_height * 0.5)))
        # Box height should be slightly smaller than row height
        box_half_height = min(10, int(row_height * 0.4))
        # Box width based on max number of digits (50 = 2 digits)
        box_half_width = max(15, int(box_half_height * 1.5))

        # Draw rows and create numbered elements
        self.elements.clear()
        for row_num in range(1, max_rows + 1):
            y_pos = (row_num - 0.5) * row_height

            # Ensure y_pos is within screen bounds
            if y_pos >= screen_height:
                break

            # Draw horizontal line
            self.canvas.create_line(
                0, y_pos, screen_width, y_pos,
                fill="cyan", width=1, dash=(5, 5)
            )

            # Store element position (center of screen at this row)
            center_x = screen_width // 2
            self.elements[row_num] = (center_x, int(y_pos), screen_width, row_height)

            # Create label with background (at left edge)
            label_x = 30
            self.canvas.create_rectangle(
                label_x - box_half_width,
                y_pos - box_half_height,
                label_x + box_half_width,
                y_pos + box_half_height,
                fill="cyan",
                outline="blue",
                width=1,
            )
            self.canvas.create_text(
                label_x,
                y_pos,
                text=str(row_num),
                font=("Arial", font_size, "bold"),
                fill="black",
            )

        self.mode = "rows"
        self.is_visible = True
        print(f"âœ“ Row overlay shown with {len(self.elements)} rows")
        print("  Say '[NUMBER] to [NUMBER]' to select rows")
        print("  Say 'HIDE NUMBERS' to close")

    def show_commands(self):
        """Show available voice commands overlay."""
        # Queue the GUI operations
        self._queue_command(self._show_commands_impl)

    def _show_commands_impl(self):
        """Implementation of show_commands - runs on GUI thread."""
        self._cleanup_impl()

        # Get screen size
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()

        # Setup overlay window
        self.root.deiconify()  # Show window
        self.root.attributes("-fullscreen", True)
        self.root.attributes("-topmost", True)
        self.root.attributes("-alpha", 0.95)
        self.root.config(bg="#1a1a1a")
        self.root.title("Voice Commands")

        # Create scrollable frame
        if self.canvas:
            self.canvas.delete("all")
            self.canvas.destroy()

        # Create canvas with scrollbar
        self.canvas = tk.Canvas(
            self.root,
            bg="#1a1a1a",
            highlightthickness=0,
        )
        scrollbar = tk.Scrollbar(self.root, orient="vertical", command=self.canvas.yview)
        scrollable_frame = tk.Frame(self.canvas, bg="#1a1a1a")

        scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )

        self.canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=scrollbar.set)

        # Title
        title = tk.Label(
            scrollable_frame,
            text="ðŸ“‹ AVAILABLE VOICE COMMANDS",
            font=("Arial", 20, "bold"),
            bg="#1a1a1a",
            fg="#00ff00",
            pady=20
        )
        title.pack()

        # Command categories
        commands = {
            "ðŸŽ¯ BASIC COMMANDS": [
                "ENTER - Press Enter key",
                "SPACE - Press Space key",
                "TAB - Press Tab key",
                "CYCLE - Press Shift+Tab (backward)",
                "ESCAPE - Press Escape key",
                "DELETE - Press Backspace",
                "START MENU / WINDOWS KEY - Open Start Menu",
            ],
            "âŒ¨ï¸ KEYBOARD SHORTCUTS": [
                "COPY - Copy selection (Ctrl+C)",
                "PASTE - Paste clipboard (Ctrl+V)",
                "CUT - Cut selection (Ctrl+X)",
                "SELECT ALL - Select all (Ctrl+A)",
                "SAVE - Save file (Ctrl+S)",
                "FIND - Open find (Ctrl+F)",
                "UNDO - Undo last action (Ctrl+Z)",
                "REDO - Redo last action (Ctrl+Y)",
                "CLOSE - Close window (Alt+F4)",
            ],
            "ðŸªŸ WINDOW MANAGEMENT": [
                "WINDOWS / SHOW WINDOWS - Show numbered windows",
                "[NUMBER] - Switch to window (when windows shown)",
                "[N] LEFT [M] RIGHT - Arrange 2 windows side-by-side",
                "MAXIMIZE - Maximize window (Win+Up)",
                "MINIMIZE - Minimize window (Win+Down)",
                "MOVE WINDOW LEFT - Snap to left (Win+Left)",
                "MOVE WINDOW RIGHT - Snap to right (Win+Right)",
                "SWITCH / SWITCH WINDOW - Next window (Alt+Tab)",
                "SWITCH TAB - Next browser tab (Ctrl+Tab)",
            ],
            "ðŸ–±ï¸ MOUSE & GRID": [
                "GRID - Show 9Ã—9 numbered grid",
                "REFINE [NUMBER] - Zoom into grid cell",
                "NUMBERS / SHOW NUMBERS - Auto-detect UI elements",
                "[NUMBER] - Move to grid/element (when shown)",
                "CLICK - Left click",
                "CLICK [NUMBER] - Click numbered element",
                "RIGHT CLICK - Right click",
                "MOVE UP/DOWN/LEFT/RIGHT - Move mouse (exponential)",
                "SCROLL UP/DOWN/LEFT/RIGHT - Scroll (exponential)",
            ],
            "ðŸ“Š ROW SELECTION": [
                "ROWS / SHOW ROWS - Show 50 numbered rows",
                "[N] TO [M] - Select rows N to M",
            ],
            "â¬…ï¸ ARROW KEYS": [
                "LEFT - Press left arrow",
                "RIGHT - Press right arrow",
                "UP - Press up arrow",
                "DOWN - Press down arrow",
            ],
            "ðŸ”£ SYMBOL TYPING": [
                "SLASH / - Forward slash",
                "BACKSLASH \\ - Backslash",
                "OPEN / CLOSE ( ) - Parentheses",
                "CURLY OPEN / CLOSE { } - Curly braces",
                "ARRAY OPEN / CLOSE [ ] - Square brackets",
                "EQUAL = - Equals sign",
                "QUOTATION \" - Double quote",
                "TICK ' - Single quote/apostrophe",
                "DOLLAR $ - Dollar sign",
                "AND & - Ampersand",
                "QUESTION ? - Question mark",
                "EXCLAMATION ! - Exclamation mark",
                "PERCENT % - Percent sign",
                "STAR * - Asterisk",
                "PLUS + - Plus sign",
                "MINUS - - Minus/dash",
                "DOT . - Period/dot",
                "COLON : - Colon",
                "SEMICOLON ; - Semicolon",
                "COMMA , - Comma",
                "HASHTAG # - Hash/pound sign",
                "GREATER > / SMALLER < - Angle brackets",
                "BAR | - Pipe/vertical bar",
                "ELEVATE ^ - Caret",
                "ROUND ~ - Tilde",
            ],
            "ðŸ“ TEXT & NAVIGATION": [
                "TYPE [TEXT] - Type dictated text",
                "GO TO START/TOP - Jump to document start",
                "GO TO END/BOTTOM - Jump to document end",
                "PAGE UP - Page up",
                "PAGE DOWN - Page down",
                "SELECT LINE - Select current line",
                "SELECT WORD - Select current word",
                "DELETE WORD - Delete previous word",
                "BACKSPACE [N] - Backspace N times",
            ],
            "ðŸš€ SYSTEM": [
                "OPEN SHELL / START SHELL - Open cmd.exe",
                "OPEN EXPLORER / START EXPLORER - Open file explorer",
                "AGENT STOP - Pause command recognition",
                "AGENT START - Resume command recognition",
            ],
            "âŒ HIDE OVERLAYS": [
                "HIDE NUMBERS/GRID/ROWS - Close overlay",
                "HIDE COMMANDS - Close this help",
            ],
        }

        # Display commands by category
        for category, cmd_list in commands.items():
            # Category header
            header = tk.Label(
                scrollable_frame,
                text=category,
                font=("Arial", 14, "bold"),
                bg="#2a2a2a",
                fg="#00ccff",
                anchor="w",
                padx=20,
                pady=8
            )
            header.pack(fill="x", padx=20, pady=(10, 0))

            # Commands in category
            for cmd in cmd_list:
                label = tk.Label(
                    scrollable_frame,
                    text="  â€¢ " + cmd,
                    font=("Consolas", 11),
                    bg="#1a1a1a",
                    fg="#cccccc",
                    anchor="w",
                    padx=30,
                    pady=3
                )
                label.pack(fill="x", padx=20)

        # Footer
        footer = tk.Label(
            scrollable_frame,
            text="Say 'HIDE COMMANDS' to close this help",
            font=("Arial", 12, "italic"),
            bg="#1a1a1a",
            fg="#888888",
            pady=30
        )
        footer.pack()

        # Pack canvas and scrollbar
        self.canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        self.mode = "commands"
        self.is_visible = True
        print("âœ“ Commands overlay shown")
        print("  Say 'HIDE COMMANDS' to close")

    def _cleanup_impl(self):
        """Clean up overlay resources - runs on GUI thread."""
        if self.canvas:
            self.canvas.delete("all")
        if self.root:
            self.root.withdraw()  # Hide instead of destroy

        self.elements = {}
        self.labels = []
        self.is_visible = False
        self.mode = None


# --- Module 4: Voice Command Processor ---


class VoiceCommandProcessor:
    """Process voice commands for mouse control and actions."""

    def __init__(self, config: Config):
        self.config = config
        self.logger = logging.getLogger("VoiceCommandProcessor")
        self.mouse_controller = mouse.Controller()
        self.keyboard_controller = keyboard.Controller()

        # Wake word configuration
        self.wake_word = config.get("wake_word", "word", default="agent").lower()
        self.wake_word_enabled = config.get("wake_word", "enabled", default=True)
        self.listening_for_command = False

        # Agent active/stopped state
        self.agent_active = True  # Agent starts active, can be paused with "agent stop"

        # Command tracking for exponential movement
        self.last_command = None
        self.command_count = 0
        self.base_step_size = 50  # Base movement in pixels

        # Get screen dimensions
        self.screen_width, self.screen_height = self._get_screen_size()
        self.logger.info(f"Screen size: {self.screen_width}x{self.screen_height}")

        # Initialize numbered overlay for screen segmentation
        self.overlay = NumberedOverlay()

        # Window list for numbered window switching
        self.window_list = {}  # Maps number -> window handle/object

        # Grid state
        self.current_grid_subdivisions = 9  # Track current grid level (9x9 default)

        # Load custom commands
        self.custom_commands_enabled = config.get("custom_commands", "enabled", default=False)
        self.custom_commands = []
        if self.custom_commands_enabled:
            commands_list = config.get("custom_commands", "commands", default=[])
            if commands_list:
                for cmd in commands_list:
                    if isinstance(cmd, dict) and "trigger" in cmd and "action" in cmd:
                        self.custom_commands.append(cmd)
                self.logger.info(f"Loaded {len(self.custom_commands)} custom commands")
            else:
                self.logger.warning("Custom commands enabled but no commands defined")

        # Load number mappings for robust speech recognition
        self.number_mappings = self._load_number_mappings()
        self.logger.info(f"Loaded {len(self.number_mappings)} number word mappings")

    def _get_screen_size(self):
        """Get screen dimensions using tkinter."""
        try:
            import tkinter as tk

            root = tk.Tk()
            root.withdraw()  # Hide the window
            width = root.winfo_screenwidth()
            height = root.winfo_screenheight()
            root.destroy()
            return width, height
        except Exception as e:
            self.logger.warning(f"Could not get screen size: {e}, using defaults")
            return 1920, 1080  # Default fallback

    def _load_number_mappings(self) -> dict:
        """Load number word mappings from number_mappings.yaml."""
        try:
            mappings_file = os.path.join(os.path.dirname(__file__), "number_mappings.yaml")
            with open(mappings_file, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
                return data.get('number_words', {})
        except FileNotFoundError:
            self.logger.warning("number_mappings.yaml not found, using default mappings")
            # Fallback to basic mappings
            return {
                "zero": 0, "one": 1, "two": 2, "to": 2, "too": 2, "three": 3,
                "four": 4, "for": 4, "five": 5, "six": 6, "seven": 7,
                "eight": 8, "ate": 8, "nine": 9, "ten": 10
            }
        except Exception as e:
            self.logger.error(f"Error loading number mappings: {e}")
            return {}

    def _check_custom_commands(self, command: str) -> Optional[str]:
        """Check if command matches any custom commands and execute."""
        command_lower = command.lower()

        for cmd_def in self.custom_commands:
            trigger = cmd_def.get("trigger", "").lower()
            if not trigger:
                continue

            # Check if command contains the trigger as a whole word (not substring)
            # Use word boundaries to avoid matching "debug" in "debugging"
            pattern = r'\b' + re.escape(trigger) + r'\b'
            if re.search(pattern, command_lower):
                action = cmd_def.get("action", {})
                action_type = action.get("type", "")

                try:
                    if action_type == "type_text":
                        # Type text action
                        text = action.get("text", "")
                        if text:
                            print("ðŸ’¬ Custom command: Typing text...")
                            # Process escape sequences
                            text = text.replace("\\n", "\n").replace("\\t", "\t")
                            return text
                        else:
                            self.logger.warning(f"Custom command '{trigger}' has no text defined")

                    elif action_type == "execute_file":
                        # Execute file action
                        path = action.get("path", "")
                        if path:
                            print(f"ðŸš€ Custom command: Executing {path}...")
                            import subprocess

                            subprocess.Popen(path, shell=True)
                            print(f"âœ“ Executed: {path}")
                        else:
                            self.logger.warning(f"Custom command '{trigger}' has no path defined")
                        return None

                    elif action_type == "key_combination":
                        # Key combination action
                        keys = action.get("keys", [])
                        if keys:
                            print(f"âŒ¨ï¸ Custom command: Pressing {' + '.join(keys)}...")
                            self._press_key_combination(keys)
                            print(f"âœ“ Pressed: {' + '.join(keys)}")
                        else:
                            self.logger.warning(f"Custom command '{trigger}' has no keys defined")
                        return None

                    else:
                        self.logger.warning(
                            f"Custom command '{trigger}' has unknown action type: {action_type}"
                        )

                except Exception as e:
                    self.logger.error(f"Error executing custom command '{trigger}': {e}")
                    print(f"âš  Error executing custom command: {e}")

                # Command matched, don't continue checking
                return None

        # No custom command matched
        return None

    def _press_key_combination(self, keys: List[str]):
        """Press a combination of keys."""
        # Map string keys to pynput keys
        key_map = {
            "ctrl": keyboard.Key.ctrl,
            "alt": keyboard.Key.alt,
            "shift": keyboard.Key.shift,
            "cmd": keyboard.Key.cmd,
            "tab": keyboard.Key.tab,
            "enter": keyboard.Key.enter,
            "space": keyboard.Key.space,
            "esc": keyboard.Key.esc,
            "backspace": keyboard.Key.backspace,
            "delete": keyboard.Key.delete,
            "home": keyboard.Key.home,
            "end": keyboard.Key.end,
            "pageup": keyboard.Key.page_up,
            "pagedown": keyboard.Key.page_down,
            "up": keyboard.Key.up,
            "down": keyboard.Key.down,
            "left": keyboard.Key.left,
            "right": keyboard.Key.right,
            "f1": keyboard.Key.f1,
            "f2": keyboard.Key.f2,
            "f3": keyboard.Key.f3,
            "f4": keyboard.Key.f4,
            "f5": keyboard.Key.f5,
            "f6": keyboard.Key.f6,
            "f7": keyboard.Key.f7,
            "f8": keyboard.Key.f8,
            "f9": keyboard.Key.f9,
            "f10": keyboard.Key.f10,
            "f11": keyboard.Key.f11,
            "f12": keyboard.Key.f12,
        }

        # Convert string keys to pynput keys
        pynput_keys = []
        for key_str in keys:
            key_str_lower = key_str.lower()
            if key_str_lower in key_map:
                pynput_keys.append(key_map[key_str_lower])
            elif len(key_str) == 1:
                # Single character key
                pynput_keys.append(key_str_lower)
            else:
                self.logger.warning(f"Unknown key: {key_str}")
                continue

        # Press all keys except the last one
        pressed_keys = []
        try:
            for key in pynput_keys[:-1]:
                self.keyboard_controller.press(key)
                pressed_keys.append(key)

            # Press and release the last key
            if pynput_keys:
                last_key = pynput_keys[-1]
                self.keyboard_controller.press(last_key)
                self.keyboard_controller.release(last_key)

            # Release all pressed keys in reverse order
            for key in reversed(pressed_keys):
                self.keyboard_controller.release(key)

        except Exception as e:
            # Make sure to release any pressed keys on error
            for key in reversed(pressed_keys):
                try:
                    self.keyboard_controller.release(key)
                except Exception:
                    pass
            raise e

    def _extract_numbers(self, text: str) -> list:
        """
        Extract numbers from text, supporting both digits and word numbers.
        Uses loaded number mappings including homophones (e.g., "to"->2, "for"->4).

        Args:
            text: Text containing numbers (e.g., "to left for right" or "2 left 4 right")

        Returns:
            List of integers found in the text
        """
        import re

        numbers = []

        # First try to find digit numbers
        digit_numbers = re.findall(r"\d+", text)
        if digit_numbers:
            return [int(n) for n in digit_numbers]

        # If no digits, try word numbers (including homophones)
        words = text.lower().split()
        for word in words:
            if word in self.number_mappings:
                numbers.append(self.number_mappings[word])

        return numbers

    def _contains_numbers(self, text: str) -> bool:
        """
        Check if text contains numbers (either digits or number words).

        Args:
            text: Text to check

        Returns:
            True if text contains digits or number words from mappings
        """
        # Check for digit characters
        if any(c.isdigit() for c in text):
            return True

        # Check for number words
        words = text.lower().split()
        for word in words:
            if word in self.number_mappings:
                return True

        return False

    def _is_lone_number(self, text: str) -> bool:
        """
        Check if text is a single number (digit or number word).

        Args:
            text: Text to check

        Returns:
            True if text is just a single number
        """
        text = text.strip()

        # Check if it's a digit number
        if text.isdigit():
            return True

        # Check if it's a single number word
        if text.lower() in self.number_mappings:
            return True

        return False

    def _parse_number(self, text: str) -> Optional[int]:
        """
        Parse a single number from text (digit or number word).

        Args:
            text: Text containing a single number

        Returns:
            Integer value or None if not a valid number
        """
        text = text.strip()

        # Try parsing as digit
        if text.isdigit():
            return int(text)

        # Try parsing as number word
        if text.lower() in self.number_mappings:
            return self.number_mappings[text.lower()]

        return None

    def _filter_ignored_words(self, text: str) -> str:
        """
        Remove ignored filler/politeness words from text.

        Args:
            text: Original text

        Returns:
            Filtered text with ignored words removed
        """
        # List of words to ignore (politeness, filler words)
        ignored_words = ["thank", "you", "thanks", "please"]

        words = text.split()
        filtered_words = []

        for word in words:
            # Strip punctuation from word for comparison
            word_clean = word.strip(".,!?;:").lower()
            if word_clean not in ignored_words:
                filtered_words.append(word)

        return " ".join(filtered_words).strip()

    def process_command(self, text: str) -> Optional[str]:
        """
        Process voice command or return text for typing.

        Args:
            text: Transcribed text

        Returns:
            Text to type, or None if command was executed
        """
        if not text:
            return None

        # Filter out ignored words (thank, you, etc.)
        text = self._filter_ignored_words(text)
        if not text:  # If all words were filtered out, ignore
            return None

        text_lower = text.lower().strip()

        # Check for agent stop/start commands (these always work)
        if "agent stop" in text_lower:
            self.agent_active = False
            print("â¸ï¸  Agent STOPPED - Commands are now paused")
            print("   Say 'AGENT START' to resume command execution")
            return None

        if "agent start" in text_lower:
            self.agent_active = True
            print("â–¶ï¸  Agent STARTED - Commands are now active")
            return None

        # If agent is stopped, ignore all speech (for when talking to someone)
        if not self.agent_active:
            return None

        # Agent is active - try to execute as command
        return self._execute_command(text_lower, original_text=text)

    def _execute_command(self, command: str, original_text: str = None) -> Optional[str]:
        """Execute a voice command."""
        command = command.strip()
        # Strip trailing punctuation that Whisper adds
        command = command.rstrip(".,!?;:")
        # Also remove commas within the command (e.g., "hide, rose" -> "hide rose")
        command = command.replace(",", " ").replace("  ", " ")
        if original_text is None:
            original_text = command

        # Check custom commands first (before built-in commands)
        if self.custom_commands_enabled:
            custom_result = self._check_custom_commands(command)
            if custom_result is not None:
                return custom_result

        # Direct key commands (short versions)
        if command == "enter":
            return self._handle_key_press_command(keyboard.Key.enter, "Enter")
        elif command == "space":
            return self._handle_key_press_command(keyboard.Key.space, "Space")
        elif command == "delete":
            return self._handle_key_press_command(keyboard.Key.backspace, "Delete")
        elif command == "tab":
            return self._handle_key_press_command(keyboard.Key.tab, "Tab")
        elif command == "cycle":
            return self._handle_shift_tab_command()
        elif command == "escape":
            return self._handle_key_press_command(keyboard.Key.esc, "Escape")
        elif command == "start menu" or command == "windows key":
            return self._handle_key_press_command(keyboard.Key.cmd, "Windows Key")

        # Symbol typing commands
        elif command == "slash":
            return self._handle_type_symbol("/", "slash")
        elif command == "backslash":
            return self._handle_type_symbol("\\", "backslash")
        elif command == "open" or command == "open paren":
            return self._handle_type_symbol("(", "open parenthesis")
        elif command == "close" or command == "close paren":
            return self._handle_type_symbol(")", "close parenthesis")
        elif command == "curly open" or command == "open curly":
            return self._handle_type_symbol("{", "open curly brace")
        elif command == "curly close" or command == "close curly":
            return self._handle_type_symbol("}", "close curly brace")
        elif command == "equal" or command == "equals":
            return self._handle_type_symbol("=", "equal")
        elif command == "quotation" or command == "quote":
            return self._handle_type_symbol('"', "quotation")
        elif command == "tick" or command == "apostrophe":
            return self._handle_type_symbol("'", "tick")
        elif command == "dollar":
            return self._handle_type_symbol("$", "dollar")
        elif command == "and" or command == "ampersand":
            return self._handle_type_symbol("&", "ampersand")
        elif command == "array open" or command == "open bracket":
            return self._handle_type_symbol("[", "open bracket")
        elif command == "array close" or command == "close bracket":
            return self._handle_type_symbol("]", "close bracket")
        elif command == "question":
            return self._handle_type_symbol("?", "question mark")
        elif command == "exclamation":
            return self._handle_type_symbol("!", "exclamation")
        elif command == "percent":
            return self._handle_type_symbol("%", "percent")
        elif command == "star" or command == "asterisk":
            return self._handle_type_symbol("*", "star")
        elif command == "plus":
            return self._handle_type_symbol("+", "plus")
        elif command == "minus" or command == "dash":
            return self._handle_type_symbol("-", "minus")
        elif command == "dot" or command == "period":
            return self._handle_type_symbol(".", "dot")
        elif command == "colon":
            return self._handle_type_symbol(":", "colon")
        elif command == "semicolon":
            return self._handle_type_symbol(";", "semicolon")
        elif command == "comma":
            return self._handle_type_symbol(",", "comma")
        elif command == "hashtag" or command == "hash" or command == "pound":
            return self._handle_type_symbol("#", "hashtag")
        elif command == "greater" or command == "greater than":
            return self._handle_type_symbol(">", "greater than")
        elif command == "smaller" or command == "less than":
            return self._handle_type_symbol("<", "less than")
        elif command == "bar" or command == "pipe":
            return self._handle_type_symbol("|", "pipe")
        elif command == "elevate" or command == "caret":
            return self._handle_type_symbol("^", "caret")
        elif command == "round" or command == "tilde":
            return self._handle_type_symbol("~", "tilde")

        # Quick keyboard shortcuts
        elif command == "copy":
            return self._handle_clipboard_command("copy")
        elif command == "paste":
            return self._handle_clipboard_command("paste")
        elif command == "cut":
            return self._handle_clipboard_command("cut")
        elif command == "select all":
            return self._handle_select_command("select all")
        elif command == "switch":
            return self._handle_switch_window_command("next")
        elif command == "save":
            return self._handle_save_command()
        elif command == "find":
            return self._handle_find_command()
        elif command == "close":
            return self._handle_close_command()
        elif command == "open shell" or command == "start shell":
            return self._handle_open_shell_command()
        elif command == "open explorer" or command == "start explorer":
            return self._handle_open_explorer_command()
        elif command == "undo":
            return self._handle_undo_redo_command("undo")
        elif command == "redo":
            return self._handle_undo_redo_command("redo")

        # Show WORD - switch to window with WORD in title
        elif command.startswith("show ") and not command.startswith("show windows") and not command.startswith("show numbers") and not command.startswith("show grid") and not command.startswith("show rows"):
            return self._handle_show_word_command(command)

        # Show rows - display numbered rows (with common speech recognition alternatives)
        elif command in ["rows", "show rows", "roles", "rose"]:
            return self._handle_show_rows_command()

        # NUMBER to NUMBER - select rows
        elif " to " in command and self._contains_numbers(command):
            return self._handle_number_to_number_command(command)

        # Window management commands (check BEFORE mouse movement)
        elif "move window left" in command or "snap left" in command:
            return self._handle_snap_window_command("left")

        elif "move window right" in command or "snap right" in command:
            return self._handle_snap_window_command("right")

        elif "maximize" in command or "maximise" in command:
            return self._handle_maximize_command()

        elif "minimize" in command or "minimise" in command:
            return self._handle_minimize_command()

        # Mouse movement commands
        elif command.startswith("move"):
            return self._handle_move_command(command)

        # Right click command
        elif command == "right click":
            return self._handle_right_click_command()

        # Click numbered element (check BEFORE regular click commands)
        elif command.startswith("click") and self._contains_numbers(command):
            return self._handle_click_number_command(command)

        # Regular click command (just "click" = left click)
        elif command == "click":
            return self._handle_click_command(command)

        # X left Y right - arrange two windows side by side
        elif "left" in command and "right" in command and self._contains_numbers(command):
            return self._handle_split_windows_command(command)

        # Lone number - context dependent on overlay mode
        elif self._is_lone_number(command) and self.overlay and self.overlay.is_visible:
            if self.overlay.mode in ["grid", "grid_zoomed"]:
                return self._handle_grid_number_command(command)
            elif self.overlay.mode == "windows":
                return self._handle_window_number_command(command)

        # Type command
        elif command.startswith("type"):
            return self._handle_type_command(command)

        # Window switching commands
        elif "switch window" in command:
            return self._handle_switch_window_command(command)

        # Switch to numbered window from overlay (just "SWITCH [number]")
        elif command.startswith("switch") and self._contains_numbers(command):
            return self._handle_switch_number_command(command)

        # Tab switching commands
        elif "switch tab" in command:
            return self._handle_switch_tab_command(command)

        # Text selection commands
        elif "select" in command:
            return self._handle_select_command(command)

        # Clipboard commands
        elif command in ["copy", "cut", "paste"]:
            return self._handle_clipboard_command(command)

        # Undo/Redo commands
        elif command in ["undo", "redo"]:
            return self._handle_undo_redo_command(command)

        # Navigation commands
        elif "go to" in command:
            return self._handle_navigation_command(command)

        # Deletion commands
        elif "delete" in command or "backspace" in command:
            return self._handle_deletion_command(command)

        # Scrolling commands
        elif "scroll" in command:
            return self._handle_scroll_command(command)

        # Page navigation
        elif "page" in command:
            return self._handle_page_command(command)

        # Arrow key commands (must be checked before window/mouse commands)
        elif command == "left":
            return self._handle_arrow_key_command("left")
        elif command == "right":
            return self._handle_arrow_key_command("right")
        elif command == "up":
            return self._handle_arrow_key_command("up")
        elif command == "down":
            return self._handle_arrow_key_command("down")

        # Window enumeration
        elif command == "windows" or "show windows" in command or "list windows" in command:
            return self._handle_show_windows_command()

        # Overlay commands for screen segmentation
        elif command == "numbers" or "show numbers" in command or "show elements" in command:
            return self._handle_show_numbers_command()

        elif command == "grid":
            return self._handle_show_grid_command()

        elif command == "commands" or "show commands" in command or "help" in command:
            return self._handle_show_commands_command()

        elif command.startswith("refine") and self._contains_numbers(command):
            return self._handle_refine_grid_command(command)

        # Hide overlay (robust matching for speech recognition errors)
        elif (
            "hide numbers" in command
            or "height numbers" in command  # Common misrecognition
            or "hide grid" in command
            or "height grid" in command  # Common misrecognition
            or "hide windows" in command
            or "height windows" in command  # Common misrecognition
            or "hide rows" in command
            or "hide rose" in command  # "rows" transcribed as "rose"
            or "hide roles" in command  # "rows" transcribed as "roles"
            or "height rows" in command  # Common misrecognition
            or "height rose" in command  # Common misrecognition
            or "height roles" in command  # Common misrecognition
            or "hide commands" in command
            or "height commands" in command  # Common misrecognition
            or "hide help" in command
            or "close overlay" in command
            or "close numbers" in command
            or "close windows" in command
            or "close rows" in command
            or "close rose" in command  # "rows" transcribed as "rose"
            or "close roles" in command  # "rows" transcribed as "roles"
            or "close commands" in command
            or "close help" in command
            or "remove overlay" in command
            or "clear overlay" in command
            or "hide overlay" in command
            or "height overlay" in command  # Common misrecognition
        ):
            return self._handle_hide_overlay_command()

        # Unknown command - ignore it (don't type)
        else:
            self.logger.info(f"No command detected, ignoring: {command}")
            return None

    def _handle_move_command(self, command: str) -> None:
        """Handle move commands - left/right snap windows, up/down move mouse."""
        # Parse direction
        if "left" in command:
            # Move left = snap window to left
            return self._handle_snap_window_command("left")
        elif "right" in command:
            # Move right = snap window to right
            return self._handle_snap_window_command("right")
        elif "up" in command:
            direction = "up"
        elif "down" in command:
            direction = "down"
        else:
            print("âš  Invalid move command. Use: MOVE UP/DOWN/LEFT/RIGHT")
            return None

        # Only mouse movement for up/down now
        # Calculate exponential step size
        if self.last_command == f"move {direction}":
            self.command_count += 1
        else:
            self.command_count = 0
            self.last_command = f"move {direction}"

        # Exponential scaling: base * 2^count, capped at 800px
        step_size = min(self.base_step_size * (2**self.command_count), 800)

        # Get current position
        current_x, current_y = self.mouse_controller.position

        # Calculate new position
        new_x, new_y = current_x, current_y

        if direction == "up":
            new_y = max(0, current_y - step_size)
        elif direction == "down":
            new_y = min(self.screen_height - 1, current_y + step_size)

        # Move mouse
        self.mouse_controller.position = (new_x, new_y)

        multiplier = 2**self.command_count
        print(
            f"ðŸ–±ï¸  Moved {direction} by {step_size}px "
            f"(x{multiplier}) â†’ ({int(new_x)}, {int(new_y)})"
        )

    def _handle_click_command(self, command: str) -> None:
        """Handle mouse click commands."""
        # Just "click" = left click
        self.mouse_controller.click(mouse.Button.left, 1)
        print("ðŸ–±ï¸  Left click")

        # Reset command tracking after click
        self.last_command = None
        self.command_count = 0

    def _handle_right_click_command(self) -> None:
        """Handle right click command."""
        self.mouse_controller.click(mouse.Button.right, 1)
        print("ðŸ–±ï¸  Right click")

        # Reset command tracking after click
        self.last_command = None
        self.command_count = 0

    def _handle_grid_number_command(self, command: str) -> None:
        """Handle lone number in grid mode - move mouse to that grid cell."""
        number = self._parse_number(command)
        if number is None:
            print(f"âš  Invalid number: {command}")
        elif number in self.overlay.elements:
            x, y, _, _ = self.overlay.elements[number]
            # Move mouse to grid cell
            self.mouse_controller.position = (x, y)
            print(f"ðŸ–±ï¸  Moved to grid cell [{number}] at ({x}, {y})")
        else:
            print(f"âš  Grid cell {number} not found")

        self.last_command = None
        self.command_count = 0

    def _handle_window_number_command(self, command: str) -> None:
        """Handle lone number in windows mode - switch to and maximize that window."""
        number = self._parse_number(command)
        if number is None:
            print(f"âš  Invalid number: {command}")
        elif self.window_list and number in self.window_list:
            window = self.window_list[number]
            title = window.window_text()
            print(f"ðŸªŸ Switching to window [{number}]: {title}")

            # Switch to the window
            self._switch_to_window(window, f"[{number}] {title}")

            # Maximize the window
            time.sleep(0.2)  # Wait for window switch to complete
            with self.keyboard_controller.pressed(keyboard.Key.cmd):
                self.keyboard_controller.press(keyboard.Key.up)
                self.keyboard_controller.release(keyboard.Key.up)
            print(f"â¬†ï¸  Maximized window [{number}]")
        else:
            print(f"âš  Window {number} not found. Use 'SHOW WINDOWS' first.")

        self.last_command = None
        self.command_count = 0

    def _handle_split_windows_command(self, command: str) -> None:
        """Handle 'X left Y right' command to arrange two windows side by side."""
        # Extract numbers from command (supports both digits and words)
        numbers = self._extract_numbers(command)
        if len(numbers) < 2:
            print("âš  Need two window numbers. Use: [number] LEFT [number] RIGHT")
            print("  Example: TWO LEFT FOUR RIGHT or 2 LEFT 4 RIGHT")
            return None

        left_window_num = numbers[0]
        right_window_num = numbers[1]

        if not self.window_list:
            print("âš  No window list. Use 'SHOW WINDOWS' first.")
            return None

        if left_window_num not in self.window_list:
            print(f"âš  Window {left_window_num} not found")
            return None

        if right_window_num not in self.window_list:
            print(f"âš  Window {right_window_num} not found")
            return None

        print(f"ðŸ“ Arranging windows: [{left_window_num}] left, [{right_window_num}] right")

        # Switch to left window and snap left
        left_window = self.window_list[left_window_num]
        left_title = left_window.window_text()
        print(f"  â¬…ï¸  Moving [{left_window_num}] {left_title} to left half")
        self._switch_to_window(left_window, f"[{left_window_num}] {left_title}")
        time.sleep(0.2)

        # Snap to left
        with self.keyboard_controller.pressed(keyboard.Key.cmd):
            self.keyboard_controller.press(keyboard.Key.left)
            self.keyboard_controller.release(keyboard.Key.left)
        time.sleep(0.15)

        # Press Enter to dismiss Snap Assist
        self.keyboard_controller.press(keyboard.Key.enter)
        self.keyboard_controller.release(keyboard.Key.enter)
        time.sleep(0.2)

        # Switch to right window and snap right
        right_window = self.window_list[right_window_num]
        right_title = right_window.window_text()
        print(f"  âž¡ï¸  Moving [{right_window_num}] {right_title} to right half")
        self._switch_to_window(right_window, f"[{right_window_num}] {right_title}")
        time.sleep(0.2)

        # Snap to right
        with self.keyboard_controller.pressed(keyboard.Key.cmd):
            self.keyboard_controller.press(keyboard.Key.right)
            self.keyboard_controller.release(keyboard.Key.right)
        time.sleep(0.15)

        # Press Enter to dismiss Snap Assist
        self.keyboard_controller.press(keyboard.Key.enter)
        self.keyboard_controller.release(keyboard.Key.enter)

        print(f"âœ“ Windows arranged: [{left_window_num}] left | [{right_window_num}] right")

        self.last_command = None
        self.command_count = 0
        return None

    def _handle_type_command(self, command: str) -> Optional[str]:
        """Handle TYPE command to dictate text."""
        # Extract text after "type"
        type_index = command.find("type")
        if type_index >= 0:
            text_to_type = command[type_index + 4 :].strip()
            if text_to_type:
                print(f"âŒ¨ï¸  Typing: '{text_to_type}'")
                self.listening_for_command = False
                self.last_command = None
                self.command_count = 0
                return text_to_type

        print("âš  No text specified after TYPE command")
        return None

    def _handle_switch_window_command(self, command: str) -> None:
        """Handle SWITCH WINDOW command to switch between applications."""
        # Parse direction or number
        if "previous" in command or "back" in command:
            # Alt+Shift+Tab for previous window
            print("ðŸªŸ Switching to previous window...")
            with self.keyboard_controller.pressed(keyboard.Key.alt):
                with self.keyboard_controller.pressed(keyboard.Key.shift):
                    self.keyboard_controller.press(keyboard.Key.tab)
                    self.keyboard_controller.release(keyboard.Key.tab)
        elif any(digit in command for digit in "0123456789"):
            # Extract number
            import re

            numbers = re.findall(r"\d+", command)
            if numbers:
                number = int(numbers[0])

                # Check if we have a numbered window list
                if self.window_list and number in self.window_list:
                    # Switch to specific numbered window
                    try:
                        window = self.window_list[number]
                        title = window.window_text()
                        print(f"ðŸªŸ Switching to window [{number}]: {title}")
                        self._switch_to_window(window, f"[{number}] {title}")
                    except Exception as e:
                        self.logger.error(f"Failed to switch to window {number}: {e}")
                        print(f"âš  Failed to switch to window {number}: {e}")
                else:
                    # Fall back to Alt+Tab N times
                    count = min(number, 20)  # Safety limit
                    print(f"ðŸªŸ Switching window {count} times...")
                    with self.keyboard_controller.pressed(keyboard.Key.alt):
                        for _ in range(count):
                            self.keyboard_controller.press(keyboard.Key.tab)
                            self.keyboard_controller.release(keyboard.Key.tab)
                            time.sleep(0.05)  # Brief delay between presses
        else:
            # Default: next window (Alt+Tab)
            print("ðŸªŸ Switching to next window...")
            with self.keyboard_controller.pressed(keyboard.Key.alt):
                self.keyboard_controller.press(keyboard.Key.tab)
                self.keyboard_controller.release(keyboard.Key.tab)

        # Reset command tracking
        self.last_command = None
        self.command_count = 0

    def _handle_switch_tab_command(self, command: str) -> None:
        """Handle SWITCH TAB command to switch between browser/app tabs."""
        # Check for previous/next
        if "previous" in command or "back" in command:
            print("ðŸ“‘ Switching to previous tab...")
            with self.keyboard_controller.pressed(keyboard.Key.ctrl):
                with self.keyboard_controller.pressed(keyboard.Key.shift):
                    self.keyboard_controller.press(keyboard.Key.tab)
                    self.keyboard_controller.release(keyboard.Key.tab)
        else:
            # Default: next tab
            print("ðŸ“‘ Switching to next tab...")
            with self.keyboard_controller.pressed(keyboard.Key.ctrl):
                self.keyboard_controller.press(keyboard.Key.tab)
                self.keyboard_controller.release(keyboard.Key.tab)

        # Reset command tracking
        self.last_command = None
        self.command_count = 0

    def _handle_switch_number_command(self, command: str) -> None:
        """Handle SWITCH [number] command to switch to numbered window from overlay."""
        # Extract number from command (supports both digits and words)
        numbers = self._extract_numbers(command)
        if not numbers:
            print("âš  No number found in switch command")
            return None

        number = numbers[0]

        # Check if we have a numbered window list from SHOW WINDOWS
        if self.window_list and number in self.window_list:
            try:
                window = self.window_list[number]
                title = window.window_text()
                print(f"ðŸªŸ Switching to window [{number}]: {title}")
                self._switch_to_window(window, f"[{number}] {title}")
            except Exception as e:
                self.logger.error(f"Failed to switch to window {number}: {e}")
                print(f"âš  Failed to switch to window {number}: {e}")
        else:
            print(f"âš  Window {number} not found. Use 'SHOW WINDOWS' first.")

        self.last_command = None
        self.command_count = 0
        return None

    def _handle_select_command(self, command: str) -> None:
        """Handle text selection commands."""
        if "all" in command:
            print("ðŸ“ Selecting all...")
            with self.keyboard_controller.pressed(keyboard.Key.ctrl):
                self.keyboard_controller.press("a")
                self.keyboard_controller.release("a")
        elif "line" in command:
            print("ðŸ“ Selecting line...")
            self.keyboard_controller.press(keyboard.Key.home)
            self.keyboard_controller.release(keyboard.Key.home)
            with self.keyboard_controller.pressed(keyboard.Key.shift):
                self.keyboard_controller.press(keyboard.Key.end)
                self.keyboard_controller.release(keyboard.Key.end)
        elif "word" in command:
            print("ðŸ“ Selecting word...")
            with self.keyboard_controller.pressed(keyboard.Key.ctrl):
                with self.keyboard_controller.pressed(keyboard.Key.shift):
                    self.keyboard_controller.press(keyboard.Key.right)
                    self.keyboard_controller.release(keyboard.Key.right)
        else:
            print("âš  Unknown select command. Use: SELECT ALL/LINE/WORD")

        self.last_command = None
        self.command_count = 0

    def _handle_clipboard_command(self, command: str) -> None:
        """Handle clipboard commands (copy, cut, paste)."""
        if command == "copy":
            print("ðŸ“‹ Copying...")
            with self.keyboard_controller.pressed(keyboard.Key.ctrl):
                self.keyboard_controller.press("c")
                self.keyboard_controller.release("c")
        elif command == "cut":
            print("âœ‚ï¸  Cutting...")
            with self.keyboard_controller.pressed(keyboard.Key.ctrl):
                self.keyboard_controller.press("x")
                self.keyboard_controller.release("x")
        elif command == "paste":
            print("ðŸ“‹ Pasting...")
            with self.keyboard_controller.pressed(keyboard.Key.ctrl):
                self.keyboard_controller.press("v")
                self.keyboard_controller.release("v")

        self.last_command = None
        self.command_count = 0

    def _handle_undo_redo_command(self, command: str) -> None:
        """Handle undo/redo commands."""
        if command == "undo":
            print("â†©ï¸  Undoing...")
            with self.keyboard_controller.pressed(keyboard.Key.ctrl):
                self.keyboard_controller.press("z")
                self.keyboard_controller.release("z")
        elif command == "redo":
            print("â†ªï¸  Redoing...")
            with self.keyboard_controller.pressed(keyboard.Key.ctrl):
                self.keyboard_controller.press("y")
                self.keyboard_controller.release("y")

        self.last_command = None
        self.command_count = 0

    def _handle_navigation_command(self, command: str) -> None:
        """Handle navigation commands (go to start/end)."""
        if "start" in command or "top" in command or "beginning" in command:
            print("â¬†ï¸  Going to start...")
            with self.keyboard_controller.pressed(keyboard.Key.ctrl):
                self.keyboard_controller.press(keyboard.Key.home)
                self.keyboard_controller.release(keyboard.Key.home)
        elif "end" in command or "bottom" in command:
            print("â¬‡ï¸  Going to end...")
            with self.keyboard_controller.pressed(keyboard.Key.ctrl):
                self.keyboard_controller.press(keyboard.Key.end)
                self.keyboard_controller.release(keyboard.Key.end)
        elif "line start" in command:
            print("â¬…ï¸  Going to line start...")
            self.keyboard_controller.press(keyboard.Key.home)
            self.keyboard_controller.release(keyboard.Key.home)
        elif "line end" in command:
            print("âž¡ï¸  Going to line end...")
            self.keyboard_controller.press(keyboard.Key.end)
            self.keyboard_controller.release(keyboard.Key.end)
        else:
            print("âš  Unknown navigation command")

        self.last_command = None
        self.command_count = 0

    def _handle_deletion_command(self, command: str) -> None:
        """Handle deletion commands (delete word, backspace N)."""
        if "word" in command:
            print("ðŸ—‘ï¸  Deleting word...")
            with self.keyboard_controller.pressed(keyboard.Key.ctrl):
                self.keyboard_controller.press(keyboard.Key.backspace)
                self.keyboard_controller.release(keyboard.Key.backspace)
        elif "backspace" in command:
            # Extract number if present
            import re

            numbers = re.findall(r"\d+", command)
            if numbers:
                count = int(numbers[0])
                count = min(count, 100)  # Safety limit
                print(f"âŒ« Backspacing {count} times...")
                for _ in range(count):
                    self.keyboard_controller.press(keyboard.Key.backspace)
                    self.keyboard_controller.release(keyboard.Key.backspace)
            else:
                print("âŒ« Backspace...")
                self.keyboard_controller.press(keyboard.Key.backspace)
                self.keyboard_controller.release(keyboard.Key.backspace)
        else:
            print("âš  Unknown deletion command")

        self.last_command = None
        self.command_count = 0

    def _handle_scroll_command(self, command: str) -> None:
        """Handle scrolling commands with exponential scaling."""
        # Determine direction
        if "up" in command:
            direction = "up"
            scroll_amount = -3
        elif "down" in command:
            direction = "down"
            scroll_amount = 3
        elif "left" in command:
            direction = "left"
            scroll_amount = -3
        elif "right" in command:
            direction = "right"
            scroll_amount = 3
        else:
            print("âš  Unknown scroll direction. Use: SCROLL UP/DOWN/LEFT/RIGHT")
            return

        # Calculate exponential step size (similar to mouse movement)
        if self.last_command == f"scroll {direction}":
            self.command_count += 1
        else:
            self.command_count = 0
            self.last_command = f"scroll {direction}"

        # Exponential scaling: 3, 6, 12, 24, capped at 48
        multiplier = min(2**self.command_count, 16)
        final_scroll = scroll_amount * multiplier

        print(f"ðŸ“œ Scrolling {direction} (x{multiplier})...")

        # Perform scroll
        if direction in ["up", "down"]:
            self.mouse_controller.scroll(0, final_scroll)
        else:  # left/right
            self.mouse_controller.scroll(final_scroll, 0)

    def _handle_page_command(self, command: str) -> None:
        """Handle page up/down commands."""
        if "up" in command:
            print("ðŸ“„ Page up...")
            self.keyboard_controller.press(keyboard.Key.page_up)
            self.keyboard_controller.release(keyboard.Key.page_up)
        elif "down" in command:
            print("ðŸ“„ Page down...")
            self.keyboard_controller.press(keyboard.Key.page_down)
            self.keyboard_controller.release(keyboard.Key.page_down)
        else:
            print("âš  Unknown page command. Use: PAGE UP or PAGE DOWN")

        self.last_command = None
        self.command_count = 0

    def _handle_arrow_key_command(self, direction: str) -> None:
        """Handle arrow key commands (left, right, up, down)."""
        direction_map = {
            "left": (keyboard.Key.left, "â¬…ï¸"),
            "right": (keyboard.Key.right, "âž¡ï¸"),
            "up": (keyboard.Key.up, "â¬†ï¸"),
            "down": (keyboard.Key.down, "â¬‡ï¸")
        }

        if direction in direction_map:
            key, emoji = direction_map[direction]
            print(f"{emoji} Pressing {direction} arrow key...")
            self.keyboard_controller.press(key)
            self.keyboard_controller.release(key)
        else:
            print(f"âš  Unknown arrow direction: {direction}")

        self.last_command = None
        self.command_count = 0

    def _handle_show_numbers_command(self) -> None:
        """Handle SHOW NUMBERS command to display numbered overlay."""
        print("ðŸ”¢ Showing numbered overlay...")
        self.overlay.show_numbers()
        self.last_command = None
        self.command_count = 0
        return None

    def _handle_show_grid_command(self) -> None:
        """Handle SHOW GRID command to display grid overlay."""
        print("ðŸ”¢ Showing 9Ã—9 grid overlay...")
        self.current_grid_subdivisions = 9  # Default is now 9x9
        self.overlay.show_grid(subdivisions=self.current_grid_subdivisions)
        self.last_command = None
        self.command_count = 0
        return None

    def _handle_show_commands_command(self) -> None:
        """Handle SHOW COMMANDS command to display available commands overlay."""
        print("ðŸ“‹ Showing available commands...")
        self.overlay.show_commands()
        self.last_command = None
        self.command_count = 0
        return None

    def _handle_refine_grid_command(self, command: str) -> None:
        """Handle REFINE [number] command to zoom into a specific cell."""
        # Extract number from command (supports both digits and words)
        numbers = self._extract_numbers(command)
        if not numbers:
            print("âš  No cell number specified. Use: REFINE [number]")
            print("  Example: REFINE FIVE or REFINE 5")
            return None

        cell_number = numbers[0]
        print(f"ðŸ” Refining grid - zooming into cell {cell_number}...")
        self.overlay.refine_grid_cell(cell_number)
        self.last_command = None
        self.command_count = 0
        return None

    def _handle_hide_overlay_command(self) -> None:
        """Handle HIDE NUMBERS/GRID command to close overlay."""
        print("âŒ Hiding overlay...")
        self.overlay.hide()
        self.last_command = None
        self.command_count = 0
        return None

    def _handle_maximize_command(self) -> None:
        """Handle MAXIMIZE command to maximize current window."""
        print("â¬†ï¸  Maximizing window...")
        # Windows: Win+Up to maximize
        if platform.system() == "Windows":
            with self.keyboard_controller.pressed(keyboard.Key.cmd):
                self.keyboard_controller.press(keyboard.Key.up)
                self.keyboard_controller.release(keyboard.Key.up)
        else:
            # On other platforms, try the same key combo
            with self.keyboard_controller.pressed(keyboard.Key.cmd):
                self.keyboard_controller.press(keyboard.Key.up)
                self.keyboard_controller.release(keyboard.Key.up)
        print("âœ“ Window maximized")
        self.last_command = None
        self.command_count = 0
        return None

    def _handle_minimize_command(self) -> None:
        """Handle MINIMIZE command to minimize current window."""
        print("â¬‡ï¸  Minimizing window...")
        # Windows: Win+Down to minimize
        if platform.system() == "Windows":
            with self.keyboard_controller.pressed(keyboard.Key.cmd):
                self.keyboard_controller.press(keyboard.Key.down)
                self.keyboard_controller.release(keyboard.Key.down)
        else:
            # On other platforms, try Cmd+M (macOS) or Cmd+H
            with self.keyboard_controller.pressed(keyboard.Key.cmd):
                self.keyboard_controller.press("m")
                self.keyboard_controller.release("m")
        print("âœ“ Window minimized")
        self.last_command = None
        self.command_count = 0
        return None

    def _handle_snap_window_command(self, direction: str) -> None:
        """Handle MOVE WINDOW LEFT/RIGHT command to snap window to half screen (Windows)."""
        if direction == "left":
            print("â¬…ï¸  Snapping window to left half...")
            with self.keyboard_controller.pressed(keyboard.Key.cmd):
                self.keyboard_controller.press(keyboard.Key.left)
                self.keyboard_controller.release(keyboard.Key.left)
            print("âœ“ Window snapped to left")
        elif direction == "right":
            print("âž¡ï¸  Snapping window to right half...")
            with self.keyboard_controller.pressed(keyboard.Key.cmd):
                self.keyboard_controller.press(keyboard.Key.right)
                self.keyboard_controller.release(keyboard.Key.right)
            print("âœ“ Window snapped to right")

        # Press Enter to dismiss Windows Snap Assist overlay
        time.sleep(0.1)
        self.keyboard_controller.press(keyboard.Key.enter)
        self.keyboard_controller.release(keyboard.Key.enter)
        time.sleep(0.05)

        self.last_command = None
        self.command_count = 0
        return None

    def _handle_show_windows_command(self) -> None:
        """Handle SHOW WINDOWS command to enumerate all open windows."""
        print("ðŸªŸ Enumerating windows...")
        self.window_list.clear()

        if not PYWINAUTO_AVAILABLE:
            print("âš  pywinauto required. Install with: pip install pywinauto")
            return None

        try:
            from pywinauto import Desktop

            desktop = Desktop(backend="uia")
            windows = desktop.windows()

            # Filter visible windows with titles
            numbered_windows = {}
            idx = 1
            for window in windows:
                try:
                    if window.is_visible():
                        title = window.window_text()
                        # Skip empty titles and certain system windows
                        if (
                            title
                            and title.strip()
                            and not title.startswith("MSCTFIME")
                            and title != "Program Manager"
                        ):
                            self.window_list[idx] = window
                            numbered_windows[idx] = (window, title)
                            idx += 1
                except Exception:
                    continue

            # Display windows in overlay
            if numbered_windows:
                print(f"âœ“ Found {len(numbered_windows)} windows")
                self.overlay.show_windows(numbered_windows)
            else:
                print("âš  No windows found")

        except Exception as e:
            self.logger.error(f"Failed to enumerate windows: {e}")
            print(f"âš  Failed to enumerate windows: {e}")

        self.last_command = None
        self.command_count = 0
        return None

    def _handle_click_number_command(self, command: str) -> None:
        """Handle CLICK [number] commands for numbered overlay elements."""
        # Extract number from command
        numbers = re.findall(r"\d+", command)
        if not numbers:
            print("âš  No number found in click command")
            return None

        element_number = int(numbers[0])

        # Determine click type
        if "right" in command:
            button = "right"
        elif "middle" in command:
            button = "middle"
        elif "double" in command:
            button = "double"
        else:
            button = "left"

        # Perform click
        self.overlay.click_element(element_number, button=button)

        self.last_command = None
        self.command_count = 0
        return None

    def _handle_key_press_command(self, key, key_name: str) -> None:
        """Handle direct key press commands."""
        print(f"âŒ¨ï¸  Pressing {key_name}...")
        self.keyboard_controller.press(key)
        self.keyboard_controller.release(key)
        print(f"âœ“ {key_name} pressed")
        self.last_command = None
        self.command_count = 0
        return None

    def _handle_shift_tab_command(self) -> None:
        """Handle CYCLE command (Shift+Tab)."""
        print("ðŸ”„ Cycling backward (Shift+Tab)...")
        with self.keyboard_controller.pressed(keyboard.Key.shift):
            self.keyboard_controller.press(keyboard.Key.tab)
            self.keyboard_controller.release(keyboard.Key.tab)
        print("âœ“ Cycled backward")
        self.last_command = None
        self.command_count = 0
        return None

    def _handle_type_symbol(self, symbol: str, symbol_name: str) -> None:
        """
        Handle typing a symbol character.

        Args:
            symbol: The symbol to type
            symbol_name: Human-readable name for logging
        """
        print(f"âŒ¨ï¸  Typing {symbol_name}: {symbol}")
        self.keyboard_controller.type(symbol)
        print(f"âœ“ Typed {symbol_name}")
        self.last_command = None
        self.command_count = 0
        return None

    def _handle_save_command(self) -> None:
        """Handle SAVE command (Ctrl+S)."""
        print("ðŸ’¾ Saving...")
        with self.keyboard_controller.pressed(keyboard.Key.ctrl):
            self.keyboard_controller.press("s")
            self.keyboard_controller.release("s")
        print("âœ“ Saved")
        self.last_command = None
        self.command_count = 0
        return None

    def _handle_find_command(self) -> None:
        """Handle FIND command (Ctrl+F)."""
        print("ðŸ” Opening Find...")
        with self.keyboard_controller.pressed(keyboard.Key.ctrl):
            self.keyboard_controller.press("f")
            self.keyboard_controller.release("f")
        print("âœ“ Find opened")
        self.last_command = None
        self.command_count = 0
        return None

    def _handle_close_command(self) -> None:
        """Handle CLOSE command (Alt+F4)."""
        print("âŒ Closing window...")
        with self.keyboard_controller.pressed(keyboard.Key.alt):
            self.keyboard_controller.press(keyboard.Key.f4)
            self.keyboard_controller.release(keyboard.Key.f4)
        print("âœ“ Window closed")
        self.last_command = None
        self.command_count = 0
        return None

    def _handle_open_shell_command(self) -> None:
        """Handle OPEN SHELL command to start a new cmd window."""
        print("ðŸ–¥ï¸  Opening new shell...")
        try:
            import subprocess
            subprocess.Popen(["cmd.exe"], creationflags=subprocess.CREATE_NEW_CONSOLE)
            print("âœ“ Shell opened")
        except Exception as e:
            self.logger.error(f"Failed to open shell: {e}")
            print(f"âš  Failed to open shell: {e}")

        self.last_command = None
        self.command_count = 0
        return None

    def _handle_open_explorer_command(self) -> None:
        """Handle OPEN EXPLORER command to open a new explorer window."""
        print("ðŸ“ Opening new explorer window...")
        try:
            import subprocess
            subprocess.Popen(["explorer.exe"])
            print("âœ“ Explorer opened")
        except Exception as e:
            self.logger.error(f"Failed to open explorer: {e}")
            print(f"âš  Failed to open explorer: {e}")

        self.last_command = None
        self.command_count = 0
        return None

    def _handle_show_word_command(self, command: str) -> None:
        """Handle 'show WORD' command to switch to window with WORD in title."""
        # Extract the word after "show "
        word = command[5:].strip()
        if not word:
            print("âš  No window name specified")
            return None

        print(f"ðŸ” Looking for window with '{word}' in title...")

        if not PYWINAUTO_AVAILABLE:
            print("âš  pywinauto required. Install with: pip install pywinauto")
            return None

        try:
            from pywinauto import Desktop

            desktop = Desktop(backend="uia")
            windows = desktop.windows()

            # Find windows with matching title
            matches = []
            for window in windows:
                try:
                    if window.is_visible():
                        title = window.window_text()
                        if title and word.lower() in title.lower():
                            matches.append((window, title))
                except Exception:
                    continue

            if not matches:
                print(f"âš  No window found with '{word}' in title")
                return None

            if len(matches) == 1:
                # Exact match - switch directly
                window, title = matches[0]
                print(f"âœ“ Found: {title}")
                print(f"ðŸªŸ Switching to window...")
                self._switch_to_window(window, title)
            else:
                # Multiple matches - show them
                print(f"âœ“ Found {len(matches)} windows with '{word}':")
                for i, (_, title) in enumerate(matches[:10], 1):
                    print(f"  {i}. {title}")
                # Switch to first match
                window, title = matches[0]
                self._switch_to_window(window, title)

        except Exception as e:
            self.logger.error(f"Failed to find window: {e}")
            print(f"âš  Failed to find window: {e}")

        self.last_command = None
        self.command_count = 0
        return None

    def _switch_to_window(self, window, title: str) -> bool:
        """
        Robustly switch to a window using multiple methods and retries.

        Returns True if successful, False otherwise.
        """
        if not PYWINAUTO_AVAILABLE:
            return False

        import ctypes

        try:
            hwnd = window.handle
        except Exception as e:
            self.logger.error(f"Failed to get window handle: {e}")
            return False

        # Try multiple methods to switch to the window
        max_attempts = 3
        for attempt in range(max_attempts):
            try:
                # Method 1: Restore if minimized
                try:
                    if window.is_minimized():
                        window.restore()
                        time.sleep(0.15)
                except Exception as e:
                    self.logger.debug(f"Restore failed: {e}")

                # Method 2: Use Windows API - aggressive activation
                try:
                    # Show window (in case it's hidden)
                    SW_SHOW = 5
                    SW_RESTORE = 9
                    ctypes.windll.user32.ShowWindow(hwnd, SW_RESTORE)
                    time.sleep(0.05)

                    # Bring window to top
                    ctypes.windll.user32.BringWindowToTop(hwnd)
                    time.sleep(0.05)

                    # Make window topmost temporarily (more aggressive)
                    SWP_NOSIZE = 0x0001
                    SWP_NOMOVE = 0x0002
                    SWP_SHOWWINDOW = 0x0040
                    HWND_TOPMOST = -1
                    HWND_NOTOPMOST = -2

                    ctypes.windll.user32.SetWindowPos(
                        hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW
                    )
                    time.sleep(0.05)

                    # Bring to foreground
                    ctypes.windll.user32.SetForegroundWindow(hwnd)
                    time.sleep(0.15)

                    # Remove topmost flag
                    ctypes.windll.user32.SetWindowPos(
                        hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW
                    )
                    time.sleep(0.05)

                except Exception as e:
                    self.logger.debug(f"Windows API method failed: {e}")
                    # Method 3: Try pywinauto set_focus
                    try:
                        window.set_focus()
                        time.sleep(0.1)
                    except Exception as e2:
                        self.logger.debug(f"set_focus failed: {e2}")

                # Verify the window is now in foreground
                try:
                    foreground_hwnd = ctypes.windll.user32.GetForegroundWindow()
                    if foreground_hwnd == hwnd:
                        print(f"âœ“ Switched to '{title}'")
                        return True
                except Exception:
                    pass

                # If verification failed but no exception, maybe it worked
                if attempt == max_attempts - 1:
                    print(f"âœ“ Attempted to switch to '{title}'")
                    return True

            except Exception as e:
                self.logger.warning(f"Switch attempt {attempt + 1} failed: {e}")
                if attempt < max_attempts - 1:
                    time.sleep(0.2)  # Wait before retry
                else:
                    print(f"âš  Failed to switch to window after {max_attempts} attempts: {e}")
                    return False

        return False

    def _handle_show_rows_command(self) -> None:
        """Handle 'show rows' command to display numbered rows on screen."""
        if not PYAUTOGUI_AVAILABLE:
            print("âš  PyAutoGUI not available. Install with: pip install pyautogui")
            return None

        print("ðŸ“Š Showing numbered rows...")
        # Use overlay to show rows
        self.overlay.show_rows()
        self.last_command = None
        self.command_count = 0
        return None

    def _handle_number_to_number_command(self, command: str) -> None:
        """Handle 'NUMBER to NUMBER' command to select rows."""
        # Extract numbers from command
        import re
        numbers = re.findall(r"\d+", command)
        if len(numbers) < 2:
            print("âš  Need two numbers for row selection (e.g., '5 to 10')")
            return None

        start_row = int(numbers[0])
        end_row = int(numbers[1])

        print(f"ðŸ“ Selecting rows {start_row} to {end_row}...")

        # Calculate clicks needed
        # First click on start row, then shift+click on end row
        if not self.overlay.is_visible or self.overlay.mode != "rows":
            print("âš  Show rows first with 'show rows' command")
            return None

        # Click start row
        if start_row in self.overlay.elements:
            x, y, _, _ = self.overlay.elements[start_row]
            pyautogui.click(x, y)
            time.sleep(0.1)

            # Shift+click end row
            if end_row in self.overlay.elements:
                x2, y2, _, _ = self.overlay.elements[end_row]
                # Hold shift and click
                pyautogui.keyDown('shift')
                pyautogui.click(x2, y2)
                pyautogui.keyUp('shift')
                print(f"âœ“ Selected rows {start_row} to {end_row}")
            else:
                print(f"âš  Row {end_row} not found")
        else:
            print(f"âš  Row {start_row} not found")

        self.last_command = None
        self.command_count = 0
        return None


# --- Module 5: Text Processor ---


class TextProcessor:
    """Process transcribed text with punctuation commands and custom vocabulary."""

    def __init__(self, config: Config):
        self.config = config
        self.punctuation_map = config.get("text_processing", "punctuation_map", default={})
        self.custom_vocabulary = config.get("text_processing", "custom_vocabulary", default={})
        self.command_words = config.get("text_processing", "command_words", default={})
        self.last_text = ""

    def process(self, text: str) -> Optional[str]:
        """Process text with punctuation commands and custom vocabulary."""
        if not text:
            return None

        # Check for command words
        text_lower = text.lower().strip()
        if text_lower in self.command_words:
            command = self.command_words[text_lower]
            self._execute_command(command)
            return None  # Don't type command words

        # Apply punctuation commands
        if self.config.get("text_processing", "punctuation_commands", default=True):
            text = self._apply_punctuation_commands(text)

        # Apply custom vocabulary
        text = self._apply_custom_vocabulary(text)

        self.last_text = text
        return text

    def _apply_punctuation_commands(self, text: str) -> str:
        """Replace spoken punctuation with actual punctuation marks."""
        if not self.punctuation_map:
            return text

        # Sort by length descending to avoid partial matches (e.g., "period" before "per")
        words = sorted(self.punctuation_map.keys(), key=len, reverse=True)
        pattern = r"\b(" + "|".join(map(re.escape, words)) + r")\b"

        def repl(match):
            word = match.group(0)
            # Use original case-insensitive mapping
            for k in self.punctuation_map:
                if word.lower() == k.lower():
                    return self.punctuation_map[k]
            return word

        text = re.sub(pattern, repl, text, flags=re.IGNORECASE)

        # Clean up extra spaces around punctuation
        text = re.sub(r"\s+([.,!?;:])", r"\1", text)
        text = re.sub(r"\s+", " ", text)
        return text.strip()

    def _apply_custom_vocabulary(self, text: str) -> str:
        """Apply custom vocabulary replacements."""
        for phrase, replacement in self.custom_vocabulary.items():
            text = re.sub(r"\b" + re.escape(phrase) + r"\b", replacement, text, flags=re.IGNORECASE)
        return text

    def _execute_command(self, command: str) -> None:
        """Execute a command word action."""
        if command == "undo_last":
            # Delete the last transcribed text
            if self.last_text:
                controller = keyboard.Controller()
                for _ in range(len(self.last_text)):
                    controller.press(keyboard.Key.backspace)
                    controller.release(keyboard.Key.backspace)
                logging.info("Undid last transcription")
        elif command == "clear_line":
            # Clear the current line
            controller = keyboard.Controller()
            controller.press(keyboard.Key.ctrl)
            controller.press(keyboard.Key.backspace)
            controller.release(keyboard.Key.backspace)
            controller.release(keyboard.Key.ctrl)
            logging.info("Cleared line")


# --- Module 5: Voice Activity Detector ---


class VoiceActivityDetector:
    """Detect silence/speech using audio energy analysis."""

    def __init__(self, sample_rate: int, chunk_size: int, energy_threshold: float = 0.01):
        self.sample_rate = sample_rate
        self.chunk_size = chunk_size
        self.energy_threshold = energy_threshold
        self.last_speech_time = time.time()
        self.speech_detected = False

    def is_speech(self, audio_data: bytes) -> bool:
        """
        Detect if audio chunk contains speech using RMS energy.

        Args:
            audio_data: Raw audio bytes (16-bit PCM)

        Returns:
            True if speech detected, False if silence
        """
        # Convert bytes to numpy array
        if not audio_data or len(audio_data) == 0:
            return False

        audio_array = np.frombuffer(audio_data, dtype=np.int16)

        if len(audio_array) == 0:
            return False

        # Calculate RMS (Root Mean Square) energy
        # Use float64 to avoid overflow, then clip to prevent sqrt of negative
        mean_square = np.mean(audio_array.astype(np.float64) ** 2)
        rms = np.sqrt(np.maximum(mean_square, 0))

        # Normalize to 0-1 range (16-bit audio has max value of 32767)
        normalized_rms = rms / 32767.0

        # Detect speech if energy exceeds threshold
        is_speech_detected = normalized_rms > self.energy_threshold

        if is_speech_detected:
            self.last_speech_time = time.time()
            self.speech_detected = True

        return is_speech_detected

    def get_silence_duration(self) -> float:
        """Get duration of silence in seconds since last speech."""
        return time.time() - self.last_speech_time

    def reset(self) -> None:
        """Reset the detector state."""
        self.last_speech_time = time.time()
        self.speech_detected = False


# --- Module 6: Dictation Engine ---


class DictationEngine:
    """Main dictation engine handling recording, transcription, and text injection."""

    def __init__(self, config: Config):
        self.config = config
        self.logger = logging.getLogger("DictationEngine")

        # State management with thread safety
        self.is_recording = False
        self.recording_lock = threading.Lock()

        # Wake word always listening mode
        self.wake_word_always_listening = config.get("wake_word", "always_listening", default=False)

        # If always listening for wake word, enable continuous mode by default
        self.continuous_mode = (
            config.get("continuous_mode", "enabled", default=False)
            or self.wake_word_always_listening
        )
        self.continuous_mode_lock = threading.Lock()
        self.audio_frames = []
        self.audio_frames_lock = threading.Lock()
        self.currently_pressed = set()
        self.stream = None
        self.running = threading.Event()
        self.running.set()

        # Failure tracking for auto-restart
        self.consecutive_failures = 0
        self.max_consecutive_failures = 3

        # Initialize components
        self.p = pyaudio.PyAudio()
        self.text_processor = TextProcessor(config)
        self.command_processor = VoiceCommandProcessor(config)
        self.whisper_model = self._load_whisper_model()

        # Audio settings
        self.sample_rate = config.get("audio", "sample_rate", default=16000)
        self.channels = config.get("audio", "channels", default=1)
        self.chunk_size = config.get("audio", "chunk_size", default=1024)
        if self.chunk_size <= 0:
            raise ValueError("chunk_size must be greater than 0")
        self.format = pyaudio.paInt16

        # VAD (Voice Activity Detection) for silence detection
        silence_duration_config = config.get("continuous_mode", "silence_threshold", default=2.0)
        self.silence_duration = silence_duration_config
        self.min_audio_length = config.get("continuous_mode", "minimum_audio_length", default=0.5)
        self.vad = VoiceActivityDetector(self.sample_rate, self.chunk_size, energy_threshold=0.02)
        self.vad_monitor_thread = None
        self.last_audio_chunk = None

        # Hotkeys
        self.push_to_talk_keys = self._parse_hotkeys(
            config.get("hotkeys", "push_to_talk", default=["ctrl", "cmd"])
        )
        self.toggle_continuous_keys = self._parse_hotkeys(
            config.get("hotkeys", "toggle_continuous", default=["ctrl", "shift", "d"])
        )

    def _parse_hotkeys(self, key_names: List[str]) -> Set:
        """Convert key names from config to pynput Key objects."""
        if not key_names:
            raise ValueError("Hotkey list cannot be empty")
        keys = set()
        for key_name in key_names:
            key_name = key_name.lower()
            if hasattr(keyboard.Key, key_name):
                keys.add(getattr(keyboard.Key, key_name))
            else:
                # Regular key (letter/number)
                try:
                    keys.add(keyboard.KeyCode.from_char(key_name))
                except Exception as e:
                    self.logger.warning(f"Unknown key: {key_name} - {e}")
        return keys

    def _load_whisper_model(self) -> WhisperModel:
        """Load the Whisper model based on configuration."""
        model_name = self.config.get("model", "name", default="small.en")
        device = self.config.get("model", "device", default="auto")
        compute_type = self.config.get("model", "compute_type", default="int8")

        print(f"Loading transcription model ({model_name})...")
        print("This may take a moment on first run...")

        # Auto-detect device
        if device == "auto":
            try:
                model = WhisperModel(model_name, device="cuda", compute_type=compute_type)
                print(f"âœ“ Model '{model_name}' ({compute_type}) loaded on GPU")
                return model
            except Exception as e:
                self.logger.info(f"GPU not available: {e}")
                self.logger.info("Falling back to CPU...")
                device = "cpu"

        try:
            model = WhisperModel(model_name, device=device, compute_type=compute_type)
            print(f"âœ“ Model '{model_name}' ({compute_type}) loaded on {device.upper()}")
            return model
        except Exception as e:
            self.logger.error(f"Failed to load model: {e}")
            print("âœ— Failed to load model. Please check your configuration.")
            sys.exit(1)

    def audio_callback(self, in_data, _frame_count, _time_info, _status):
        """PyAudio callback for recording audio."""
        with self.recording_lock:
            is_recording = self.is_recording
        if is_recording:
            with self.audio_frames_lock:
                self.audio_frames.append(in_data)
            self.last_audio_chunk = in_data  # Store for VAD monitoring
            return (in_data, pyaudio.paContinue)
        return (in_data, pyaudio.paComplete)

    def _monitor_silence(self):
        """
        Monitor audio for silence in continuous mode.
        Automatically stops recording after silence threshold is exceeded.
        """
        while True:
            with self.recording_lock:
                is_recording = self.is_recording
            with self.continuous_mode_lock:
                continuous_mode = self.continuous_mode

            if not is_recording or not continuous_mode:
                break

            if self.last_audio_chunk:
                # Check if current chunk contains speech
                self.vad.is_speech(self.last_audio_chunk)

                # Get silence duration
                silence_duration = self.vad.get_silence_duration()

                # Calculate total recording duration
                with self.audio_frames_lock:
                    num_frames = len(self.audio_frames)
                recording_duration = (num_frames * self.chunk_size) / self.sample_rate

                # Check if we should auto-stop
                if (
                    self.vad.speech_detected  # We detected speech at some point
                    and silence_duration >= self.silence_duration
                    and recording_duration >= self.min_audio_length
                ):
                    self.logger.info(
                        f"Silence detected for {silence_duration:.1f}s, auto-stopping..."
                    )
                    self.stop_recording()
                    break

            # Check every 100ms
            time.sleep(0.1)

    def start_recording(self):
        """Start recording audio."""
        with self.recording_lock:
            if self.is_recording:
                return
            self.is_recording = True

        with self.audio_frames_lock:
            self.audio_frames = []
        self.last_audio_chunk = None

        # Reset VAD detector
        self.vad.reset()

        # Play start beep
        if self.config.get("audio", "beep_on_start", default=True):
            freq = self.config.get("audio", "start_beep_frequency", default=800)
            dur = self.config.get("audio", "start_beep_duration", default=100)
            threading.Thread(
                target=AudioFeedback.play_beep, args=(freq, dur, self.p), daemon=True
            ).start()

        try:
            self.stream = self.p.open(
                format=self.format,
                channels=self.channels,
                rate=self.sample_rate,
                input=True,
                frames_per_buffer=self.chunk_size,
                stream_callback=self.audio_callback,
            )
            self.stream.start_stream()

            # Start silence monitoring thread in continuous mode
            with self.continuous_mode_lock:
                continuous_mode = self.continuous_mode
            if continuous_mode:
                self.vad_monitor_thread = threading.Thread(
                    target=self._monitor_silence, daemon=True
                )
                self.vad_monitor_thread.start()
                print("\nðŸŽ¤ Recording started... (will auto-stop after silence)")
            else:
                print("\nðŸŽ¤ Recording started...")
        except Exception as e:
            self.logger.error(f"Failed to start recording: {e}")
            with self.recording_lock:
                self.is_recording = False
            if self.stream:
                try:
                    self.stream.close()
                except Exception:
                    pass
                self.stream = None

    def stop_recording(self):
        """Stop recording and trigger transcription."""
        with self.recording_lock:
            if not self.is_recording:
                return
            self.is_recording = False

        print("â¹ Recording stopped. Processing...")

        # Play stop beep
        if self.config.get("audio", "beep_on_stop", default=True):
            freq = self.config.get("audio", "stop_beep_frequency", default=600)
            dur = self.config.get("audio", "stop_beep_duration", default=100)
            threading.Thread(
                target=AudioFeedback.play_beep, args=(freq, dur, self.p), daemon=True
            ).start()

        # Stop stream
        if self.stream and self.stream.is_active():
            self.stream.stop_stream()
        if self.stream:
            self.stream.close()
            self.stream = None

        # Transcribe in background thread
        with self.audio_frames_lock:
            frames_copy = self.audio_frames.copy()
        threading.Thread(target=self.transcribe_audio, args=(frames_copy,), daemon=True).start()

    def _inject_text(self, text: str):
        """
        Inject text using clipboard paste (most reliable method for Windows).

        Saves and restores the previous clipboard content.
        """
        try:
            import pyperclip

            # Save current clipboard content
            previous_clipboard = None
            try:
                previous_clipboard = pyperclip.paste()
            except Exception:
                pass  # Clipboard might be empty or inaccessible

            # Copy our text to clipboard
            pyperclip.copy(text)
            time.sleep(0.05)  # Small delay to ensure clipboard is updated

            # Paste using Ctrl+V
            text_injector = keyboard.Controller()
            with text_injector.pressed(keyboard.Key.ctrl):
                text_injector.press("v")
                text_injector.release("v")

            time.sleep(0.05)  # Small delay before restoring clipboard

            # Restore previous clipboard content
            if previous_clipboard is not None:
                try:
                    pyperclip.copy(previous_clipboard)
                except Exception as e:
                    self.logger.debug(f"Failed to restore clipboard: {e}")

        except ImportError:
            self.logger.error("pyperclip not installed!")
            print("âŒ ERROR: pyperclip is required for text typing")
            print("   Install with: pip install pyperclip")
        except Exception as e:
            self.logger.error(f"Clipboard paste failed: {e}")
            print(f"âš  Failed to inject text: {e}")

    def transcribe_audio(self, frames: List[bytes]):
        """Transcribe audio and inject text."""
        if not frames:
            self.logger.warning("No audio recorded")
            return

        successful = False
        t_total_start = time.time()
        timing_phases = {}

        try:
            # Create WAV buffer
            t_start_wav = time.time()
            wav_buffer = io.BytesIO()
            with wave.open(wav_buffer, "wb") as wf:
                wf.setnchannels(self.channels)
                wf.setsampwidth(self.p.get_sample_size(self.format))
                wf.setframerate(self.sample_rate)
                wf.writeframes(b"".join(frames))
            wav_buffer.seek(0)
            timing_phases['WAV'] = (time.time() - t_start_wav) * 1000

            # Transcribe
            print("ðŸ§  Transcribing...")
            t_start_transcribe = time.time()
            beam_size = self.config.get("model", "beam_size", default=5)
            language = self.config.get("model", "language", default="en")

            segments, _info = self.whisper_model.transcribe(
                wav_buffer, beam_size=beam_size, language=language, condition_on_previous_text=False
            )

            # Collect text
            text = " ".join(segment.text for segment in segments).strip()
            timing_phases['Transcribe'] = (time.time() - t_start_transcribe) * 1000

            if text:
                print(f"âœ“ Transcription: '{text}'")

                # First, check for voice commands
                # process_command handles agent stop/start and regular commands
                t_start_command = time.time()
                command_result = self.command_processor.process_command(text)
                timing_phases['Command'] = (time.time() - t_start_command) * 1000

                # If command processor returns text to type, type it
                # command_result is None if a command was executed
                # command_result is text if no command was detected or agent is stopped
                if command_result is not None:
                    t_start_text = time.time()
                    text_to_process = command_result
                    processed_text = self.text_processor.process(text_to_process)

                    if processed_text:
                        print("âŒ¨ï¸  Typing text...")
                        self._inject_text(processed_text)
                        timing_phases['TextType'] = (time.time() - t_start_text) * 1000
                        print("âœ“ Done!")

                # Calculate total time
                timing_phases['TOTAL'] = (time.time() - t_total_start) * 1000

                # Display timing breakdown
                print("â±ï¸  Timing breakdown:")
                print(f"   WAV creation:    {timing_phases['WAV']:>6.0f}ms")
                print(f"   Transcription:   {timing_phases['Transcribe']:>6.0f}ms")
                print(f"   Command process: {timing_phases['Command']:>6.0f}ms")
                if 'TextType' in timing_phases:
                    print(f"   Text typing:     {timing_phases['TextType']:>6.0f}ms")
                print(f"   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
                print(f"   TOTAL:           {timing_phases['TOTAL']:>6.0f}ms")
                print()
            else:
                print("âš  Transcription was empty.")

            successful = True

        except Exception as e:
            self.logger.error(f"Transcription error: {e}")
            print(f"âœ— Error during transcription: {e}")

        finally:
            # Auto-restart recording in continuous mode
            with self.continuous_mode_lock:
                continuous_mode = self.continuous_mode
            if continuous_mode and self.running.is_set():
                if successful:
                    self.consecutive_failures = 0
                else:
                    self.consecutive_failures += 1
                    if self.consecutive_failures >= self.max_consecutive_failures:
                        self.logger.error("Too many consecutive failures, stopping continuous mode")
                        with self.continuous_mode_lock:
                            self.continuous_mode = False
                        return

                time.sleep(0.3)  # Brief pause before restarting
                with self.continuous_mode_lock:
                    continuous_mode = self.continuous_mode
                if continuous_mode:  # Check again in case mode was toggled
                    self.logger.info("Auto-restarting recording in continuous mode...")
                    self.start_recording()

    def toggle_continuous_mode(self):
        """Toggle continuous dictation mode."""
        with self.continuous_mode_lock:
            self.continuous_mode = not self.continuous_mode
            continuous_mode = self.continuous_mode

        if continuous_mode:
            silence_sec = self.silence_duration
            print("\nðŸ”„ Continuous mode ENABLED")
            print(f"   (Speak naturally, auto-transcribes after {silence_sec}s silence)")
            self.start_recording()
        else:
            print("\nðŸ”„ Continuous mode DISABLED")
            print("   (Use push-to-talk hotkey to record)")
            with self.recording_lock:
                is_recording = self.is_recording
            if is_recording:
                self.stop_recording()

    def on_press(self, key):
        """Handle key press events."""
        # Normalize key (map left/right variants to canonical key)
        canonical_key = KEY_MAPPING.get(key, key)

        # Check for push-to-talk
        if canonical_key in self.push_to_talk_keys:
            self.currently_pressed.add(canonical_key)
            with self.continuous_mode_lock:
                continuous_mode = self.continuous_mode
            if self.currently_pressed == self.push_to_talk_keys and not continuous_mode:
                self.start_recording()

        # Check for toggle continuous mode
        if canonical_key in self.toggle_continuous_keys:
            self.currently_pressed.add(canonical_key)
            # Debug: Show what's pressed
            if self.config.get("advanced", "verbose", default=False):
                print(f"Debug: Currently pressed: {self.currently_pressed}")
                print(f"Debug: Expected: {self.toggle_continuous_keys}")
            if self.currently_pressed == self.toggle_continuous_keys:
                self.toggle_continuous_mode()

    def on_release(self, key):
        """Handle key release events."""
        # Normalize key (map left/right variants to canonical key)
        canonical_key = KEY_MAPPING.get(key, key)

        if canonical_key in self.push_to_talk_keys:
            with self.continuous_mode_lock:
                continuous_mode = self.continuous_mode
            with self.recording_lock:
                is_recording = self.is_recording
            if not continuous_mode and is_recording:
                self.stop_recording()
            if canonical_key in self.currently_pressed:
                self.currently_pressed.remove(canonical_key)

        if canonical_key in self.toggle_continuous_keys:
            if canonical_key in self.currently_pressed:
                self.currently_pressed.remove(canonical_key)

    def cleanup(self):
        """Cleanup resources."""
        self.running.clear()
        if self.stream:
            self.stream.close()
        self.p.terminate()


# --- Module 7: System Tray Icon ---


class SystemTrayIcon:
    """System tray icon for the dictation tool."""

    def __init__(self, dictation_engine: DictationEngine):
        self.engine = dictation_engine
        self.icon = None

    def create_image(self, color="green"):
        """Create icon image."""
        # Create a simple colored circle
        size = (64, 64)
        image = Image.new("RGB", size, "white")
        draw = ImageDraw.Draw(image)

        # Draw circle
        color_map = {"green": (0, 200, 0), "red": (200, 0, 0), "yellow": (200, 200, 0)}
        circle_color = color_map.get(color, (0, 200, 0))
        draw.ellipse([8, 8, 56, 56], fill=circle_color, outline="black", width=2)

        # Draw microphone icon (simple)
        draw.rectangle([28, 20, 36, 35], fill="white")
        draw.ellipse([24, 35, 40, 42], outline="white", width=2)
        draw.line([32, 42, 32, 48], fill="white", width=2)

        return image

    def on_quit(self, icon, item):
        """Handle quit action."""
        print("\nShutting down from system tray...")
        self.engine.cleanup()
        icon.stop()
        sys.exit(0)

    def on_toggle_continuous(self, icon, item):
        """Handle toggle continuous mode."""
        self.engine.toggle_continuous_mode()

    def run(self):
        """Run the system tray icon."""
        menu = Menu(
            MenuItem("Continuous Mode", self.on_toggle_continuous),
            MenuItem("Quit", self.on_quit),
        )

        self.icon = Icon("dictation", self.create_image(), "Dictation Tool", menu)
        self.icon.run()


# --- File Watcher for Auto-Reload ---


class CodeChangeHandler(FileSystemEventHandler):
    """Watches for changes to Python files and config files, then restarts the process."""

    def __init__(self):
        super().__init__()
        self.last_restart = 0
        self.restart_delay = 1.0  # Minimum seconds between restarts

    def on_modified(self, event):
        """Called when a file is modified."""
        if event.is_directory:
            return

        # Only watch specific files
        filename = os.path.basename(event.src_path)
        if filename not in ['dictation.py', 'config.yaml', 'number_mappings.yaml']:
            return

        # Debounce restarts
        now = time.time()
        if now - self.last_restart < self.restart_delay:
            return

        self.last_restart = now
        print(f"\nðŸ”„ Code change detected in {filename}, restarting...")
        time.sleep(0.5)  # Brief delay to let file write complete

        # Restart the process
        os.execv(sys.executable, [sys.executable] + sys.argv)


def start_file_watcher():
    """Start watching for file changes if watchdog is available."""
    if not WATCHDOG_AVAILABLE:
        return None

    event_handler = CodeChangeHandler()
    observer = Observer()

    # Watch current directory
    watch_path = os.path.dirname(os.path.abspath(__file__))
    observer.schedule(event_handler, watch_path, recursive=False)
    observer.start()

    print("ðŸ” Auto-reload enabled - watching for code changes...")
    return observer


# --- Main Application ---


def main():
    """Main entry point."""
    print("=" * 70)
    print("  ðŸŽ¤ Push-to-Talk Speech-to-Text Dictation Tool - Enhanced Edition")
    print("=" * 70)

    # Load configuration
    config = Config("config.yaml")

    # Start file watcher for auto-reload
    observer = start_file_watcher()

    # Initialize dictation engine
    engine = DictationEngine(config)

    # Print hotkey information
    push_to_talk = " + ".join(config.get("hotkeys", "push_to_talk", default=["ctrl", "cmd"]))
    toggle_continuous = " + ".join(
        config.get("hotkeys", "toggle_continuous", default=["ctrl", "shift", "d"])
    )

    print("\nðŸ“‹ Hotkeys:")
    print(f"   Push-to-Talk: {push_to_talk}")
    print(f"   Toggle Continuous Mode: {toggle_continuous}")
    print("\nâš™ï¸  Configuration loaded from: config.yaml")
    print(
        f"   Punctuation commands: {'âœ“' if config.get('text_processing', 'punctuation_commands') else 'âœ—'}"
    )
    print(f"   System tray: {'âœ“' if config.get('system_tray', 'enabled') else 'âœ—'}")
    print(f"   Audio feedback: {'âœ“' if config.get('audio', 'beep_on_start') else 'âœ—'}")

    # Check if always listening for wake word
    always_listening = config.get("wake_word", "always_listening", default=False)
    wake_word = config.get("wake_word", "word", default="agent").upper()
    if always_listening:
        print(f"   Wake word always listening: âœ“ ('{wake_word}')")

    print("\n" + "=" * 70)
    if always_listening:
        print(f"âœ“ Ready! Always listening for wake word '{wake_word}'...")
        print(f"   Just say '{wake_word}' followed by your command (no hotkey needed)")
    else:
        print("âœ“ Ready! Listening for hotkeys...")
    print("=" * 70 + "\n")

    # Start system tray if enabled
    if config.get("system_tray", "enabled", default=True):
        tray_icon = SystemTrayIcon(engine)
        threading.Thread(target=tray_icon.run, daemon=True).start()

    # Auto-start recording if always listening for wake word
    if always_listening:
        print("ðŸŽ¤ Starting always-on listening mode...")
        engine.start_recording()

    # Start keyboard listener
    try:
        with keyboard.Listener(on_press=engine.on_press, on_release=engine.on_release) as listener:
            listener.join()
    except KeyboardInterrupt:
        print("\n\nShutting down...")
        if observer:
            observer.stop()
            observer.join()
        engine.cleanup()
        print("Goodbye!")


if __name__ == "__main__":
    main()
